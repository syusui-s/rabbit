{"version":3,"mappings":"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","names":["sharedConfig","setHydrateContext","context","equalFn","a","b","$PROXY","$TRACK","signalOptions","runEffects","runQueue","STALE","PENDING","UNOWNED","NO_INIT","Owner","Transition","Listener","Updates","Effects","ExecCount","createRoot","fn","detachedOwner","listener","owner","unowned","root","updateFn","untrack","cleanNode","runUpdates","createSignal","value","options","s","setter","writeSignal","readSignal","createComputed","c","createComputation","updateComputation","createRenderEffect","createEffect","runUserEffects","createMemo","createResource","pSource","pFetcher","pOptions","source","fetcher","pr","initP","id","scheduled","resolved","dynamic","contexts","setValue","error","setError","track","trigger","state","setState","v","loadEnd","p","key","completeLoad","err","read","SuspenseContext","load","refetching","lookup","e","castError","batch","on","deps","isArray","prevInput","defer","prevValue","input","i","result","onMount","onCleanup","getListener","getOwner","runWithOwner","o","prev","prevListener","handleError","startTransition","l","t","createContext","defaultValue","createProvider","useContext","ctx","children","memo","resolveChildren","updates","lookUpstream","sSlot","node","isComp","current","TransitionRunning","markDownstream","time","runComputation","nextValue","init","pure","runTop","ancestors","wait","res","completeUpdates","queue","userLength","ignore","index","obs","n","results","props","observable","observer","handler","dispose","disposer","FALLBACK","d","mapArray","list","mapFn","items","mapped","disposers","len","indexes","newItems","j","newLen","newIndices","newIndicesNext","temp","tempdisposers","tempIndexes","start","end","newEnd","item","mapper","set","createComponent","Comp","trueFn","propTraps","_","property","receiver","resolveSource","mergeProps","sources","proxy","keys","target","descriptors","lazy","comp","wrap","mod","r","narrowedError","name","For","fallback","Show","keyed","condition","child","Switch","equals","conditions","evalConditions","conds","when","cond","Match","booleans","Properties","ChildProperties","Aliases","PropAliases","getPropAlias","prop","tagName","DelegatedEvents","SVGNamespace","reconcileArrays","parentNode","bLength","aEnd","bEnd","aStart","bStart","after","map","sequence","$$EVENTS","render","code","element","insert","template","html","isCE","isSVG","create","delegateEvents","eventNames","document","eventHandler","setAttribute","setAttributeNS","namespace","className","addEventListener","delegate","handlerFn","classList","classKeys","prevKeys","toggleClassKey","classValue","style","nodeStyle","spread","skipChildren","prevProps","insertExpression","assign","use","arg","parent","accessor","marker","initial","skipRef","assignProp","toPropertyName","w","classNames","nameLen","isProp","isChildProp","propAlias","forceProp","h","ns","data","unwrapArray","cleaned","multi","cleanChildren","array","currentArray","normalizeIncomingArray","appendNodes","normalized","unwrap","replacement","inserted","el","isParent","isServer","bindEvent","type","intercept","get","querySelector","selector","scrollToHash","hash","fallbackTop","createIntegration","utils","signal","next","normalizeIntegration","integration","pathIntegration","replace","scroll","notify","delta","createBeforeLeave","listeners","subscribe","confirm","to","force","hasSchemeRegex","trimPathRegex","normalizePath","path","omitSlash","resolvePath","base","from","basePath","fromPath","invariant","message","joinPaths","extractSearchParams","url","params","createMatcher","partial","matchFilters","pattern","splat","segments","location","locSegments","lenDiff","match","matchFilter","segment","locSegment","matchSegment","remainder","filter","isEqual","scoreRoute","route","score","createMemoObject","expandOptionals","prefix","suffix","prefixes","expansion","MAX_REDIRECTS","RouterContextObj","RouteContextObj","useRouter","TempRoute","useRoute","useNavigate","createRoutes","routeDef","component","isLeaf","shared","asArray","acc","originalPath","createBranch","routes","matches","createBranches","stack","branches","routeDefs","def","isEmptyArray","branch","getRouteMatches","createLocation","origin","path_","pathname","search","createRouterContext","out","setSource","parsePath","renderPath","beforeLeave","output","isRouting","setIsRouting","callback","reference","setReference","referrers","baseRoute","navigatorFactory","navigateFromRoute","resolve","nextState","resolvedTo","navigateEnd","first","handleAnchorClick","evt","href","rel","createRouteContext","router","outlet","preload","Router","routerState","_$createComponent","Provider","Routes","parentRoute","Outlet","m","length","Object","push","routeStates","nextMatches","prevMatches","equal","prevMatch","nextMatch","splice","forEach","Route","childRoutes","Subscribable","x","noop","functionalUpdate","updater","isValidTimeout","timeUntilStale","updatedAt","staleTime","parseQueryArgs","arg1","arg2","arg3","isQueryKey","parseMutationArgs","parseFilterArgs","matchQuery","filters","query","exact","fetchStatus","predicate","queryKey","stale","hashQueryKeyByOptions","partialMatchKey","isActive","matchMutation","mutation","fetching","mutationKey","hashQueryKey","val","isPlainObject","partialDeepEqual","replaceEqualDeep","isPlainArray","aSize","bItems","bSize","copy","equalItems","shallowEqualObjects","hasObjectPrototype","ctor","prot","sleep","timeout","scheduleMicrotask","getAbortController","replaceData","prevData","FocusManager","onFocus","_this$cleanup","setup","_this$cleanup2","focused","focusManager","OnlineManager","onOnline","online","onlineManager","defaultRetryDelay","failureCount","canFetch","networkMode","CancelledError","isCancelledError","createRetryer","config","isRetryCancelled","isResolved","continueFn","promiseResolve","promiseReject","promise","outerResolve","outerReject","cancel","cancelOptions","reject","cancelRetry","continueRetry","shouldPause","pause","continueResolve","canContinue","run","promiseOrValue","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","defaultLogger","createNotifyManager","transactions","notifyFn","batchNotifyFn","flush","schedule","batchCalls","args","originalQueue","notifyManager","Removable","newCacheTime","Query","getDefaultState","newData","setStateOptions","_this$retryer","_this$retryer2","_this$retryer3","fetchOptions","_this$options$behavio","_context$fetchOptions","_this$retryer4","abortController","queryFnContext","addSignalProperty","object","fetchFn","_context$fetchOptions2","onError","_this$cache$config$on","_this$cache$config","_this$cache$config$on2","_this$cache$config2","_this$cache$config$on3","_this$cache$config3","_this$cache$config$on4","_this$cache$config4","action","reducer","_action$meta","_action$dataUpdatedAt","hasData","initialDataUpdatedAt","QueryCache","client","_options$queryHash","queryHash","queryInMap","event","Mutation","_this$retryer$continu","executeMutation","_this$options$retry","restored","_this$mutationCache$c3","_this$mutationCache$c4","_this$options$onSucce","_this$options2","_this$mutationCache$c5","_this$mutationCache$c6","_this$options$onSettl","_this$options3","_this$mutationCache$c","_this$mutationCache$c2","_this$options$onMutat","_this$options","_this$mutationCache$c7","_this$mutationCache$c8","_this$options$onError","_this$options4","_this$mutationCache$c9","_this$mutationCache$c10","_this$options$onSettl2","_this$options5","MutationCache","_this$resuming","pausedMutations","infiniteQueryBehavior","_context$fetchOptions3","_context$fetchOptions4","_context$state$data","_context$state$data2","refetchPage","fetchMore","pageParam","isFetchingNextPage","isFetchingPreviousPage","oldPages","oldPageParams","newPageParams","cancelled","_context$signal","_context$signal2","queryFn","buildNewPages","pages","param","page","previous","fetchPage","manual","queryFnResult","getNextPageParam","getPreviousPageParam","QueryClient","_this$unsubscribeFocu","_this$unsubscribeOnli","_this$queryCache$find","parsedOptions","cachedData","queryKeyOrFilters","defaultedOptions","_this$queryCache$find2","queryCache","refetchFilters","promises","_ref","_filters$refetchType","_options$cancelRefetc","firstMatchingDefaults","dehydrateMutation","dehydrateQuery","defaultShouldDehydrateMutation","defaultShouldDehydrateQuery","dehydrate","mutations","queries","shouldDehydrateMutation","shouldDehydrateQuery","hydrate","dehydratedState","mutationCache","dehydratedMutation","_options$defaultOptio","dehydratedQuery","_options$defaultOptio2","dehydratedQueryState","cacheableEventTypes","isCacheableEventType","eventType","persistQueryClientRestore","queryClient","persister","maxAge","buster","hydrateOptions","persistedClient","expired","busted","persistQueryClientSave","dehydrateOptions","persistClient","persistQueryClientSubscribe","unsubscribeQueryCache","unusbscribeMutationCache","persistQueryClient","hasUnsubscribed","persistQueryClientUnsubscribe","unsubscribe","restorePromise","createSyncStoragePersister","storage","throttleTime","serialize","deserialize","trySave","throttle","errorCount","cacheString","func","timer","defaultContext","undefined","QueryClientSharingContext","getQueryClientContext","contextSharing","window","SolidQueryClientContext","useQueryClient","Error","QueryClientProvider","mergedProps","mount","unmount","QueryClientContext","Home","Hello","NotFound","localStoragePersister","localStorage","App","import","getElementById"],"sources":["../../node_modules/solid-js/dist/solid.js","../../node_modules/solid-js/web/dist/web.js","../../node_modules/@solidjs/router/dist/integration.js","../../node_modules/@solidjs/router/dist/lifecycle.js","../../node_modules/@solidjs/router/dist/utils.js","../../node_modules/@solidjs/router/dist/routing.js","../../node_modules/@solidjs/router/dist/components.jsx","../../node_modules/@tanstack/query-core/build/lib/subscribable.mjs","../../node_modules/@tanstack/query-core/build/lib/utils.mjs","../../node_modules/@tanstack/query-core/build/lib/focusManager.mjs","../../node_modules/@tanstack/query-core/build/lib/onlineManager.mjs","../../node_modules/@tanstack/query-core/build/lib/retryer.mjs","../../node_modules/@tanstack/query-core/build/lib/logger.mjs","../../node_modules/@tanstack/query-core/build/lib/notifyManager.mjs","../../node_modules/@tanstack/query-core/build/lib/removable.mjs","../../node_modules/@tanstack/query-core/build/lib/query.mjs","../../node_modules/@tanstack/query-core/build/lib/queryCache.mjs","../../node_modules/@tanstack/query-core/build/lib/mutation.mjs","../../node_modules/@tanstack/query-core/build/lib/mutationCache.mjs","../../node_modules/@tanstack/query-core/build/lib/infiniteQueryBehavior.mjs","../../node_modules/@tanstack/query-core/build/lib/queryClient.mjs","../../node_modules/@tanstack/query-core/build/lib/hydration.mjs","../../node_modules/@tanstack/query-persist-client-core/build/lib/persist.mjs","../../node_modules/@tanstack/query-sync-storage-persister/build/lib/index.mjs","../../node_modules/@tanstack/solid-query/build/solid/QueryClientProvider.jsx","../../src/App.tsx","../../src/index.tsx"],"sourcesContent":["let taskIdCounter = 1,\n  isCallbackScheduled = false,\n  isPerformingWork = false,\n  taskQueue = [],\n  currentTask = null,\n  shouldYieldToHost = null,\n  yieldInterval = 5,\n  deadline = 0,\n  maxYieldInterval = 300,\n  scheduleCallback = null,\n  scheduledCallback = null;\nconst maxSigned31BitInt = 1073741823;\nfunction setupScheduler() {\n  const channel = new MessageChannel(),\n    port = channel.port2;\n  scheduleCallback = () => port.postMessage(null);\n  channel.port1.onmessage = () => {\n    if (scheduledCallback !== null) {\n      const currentTime = performance.now();\n      deadline = currentTime + yieldInterval;\n      const hasTimeRemaining = true;\n      try {\n        const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);\n        if (!hasMoreWork) {\n          scheduledCallback = null;\n        } else port.postMessage(null);\n      } catch (error) {\n        port.postMessage(null);\n        throw error;\n      }\n    }\n  };\n  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {\n    const scheduling = navigator.scheduling;\n    shouldYieldToHost = () => {\n      const currentTime = performance.now();\n      if (currentTime >= deadline) {\n        if (scheduling.isInputPending()) {\n          return true;\n        }\n        return currentTime >= maxYieldInterval;\n      } else {\n        return false;\n      }\n    };\n  } else {\n    shouldYieldToHost = () => performance.now() >= deadline;\n  }\n}\nfunction enqueue(taskQueue, task) {\n  function findIndex() {\n    let m = 0;\n    let n = taskQueue.length - 1;\n    while (m <= n) {\n      const k = n + m >> 1;\n      const cmp = task.expirationTime - taskQueue[k].expirationTime;\n      if (cmp > 0) m = k + 1;else if (cmp < 0) n = k - 1;else return k;\n    }\n    return m;\n  }\n  taskQueue.splice(findIndex(), 0, task);\n}\nfunction requestCallback(fn, options) {\n  if (!scheduleCallback) setupScheduler();\n  let startTime = performance.now(),\n    timeout = maxSigned31BitInt;\n  if (options && options.timeout) timeout = options.timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    fn,\n    startTime,\n    expirationTime: startTime + timeout\n  };\n  enqueue(taskQueue, newTask);\n  if (!isCallbackScheduled && !isPerformingWork) {\n    isCallbackScheduled = true;\n    scheduledCallback = flushWork;\n    scheduleCallback();\n  }\n  return newTask;\n}\nfunction cancelCallback(task) {\n  task.fn = null;\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n  isCallbackScheduled = false;\n  isPerformingWork = true;\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    isPerformingWork = false;\n  }\n}\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  currentTask = taskQueue[0] || null;\n  while (currentTask !== null) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      break;\n    }\n    const callback = currentTask.fn;\n    if (callback !== null) {\n      currentTask.fn = null;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      callback(didUserCallbackTimeout);\n      currentTime = performance.now();\n      if (currentTask === taskQueue[0]) {\n        taskQueue.shift();\n      }\n    } else taskQueue.shift();\n    currentTask = taskQueue[0] || null;\n  }\n  return currentTask !== null;\n}\n\nconst sharedConfig = {\n  context: undefined,\n  registry: undefined\n};\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\nfunction nextHydrateContext() {\n  return {\n    ...sharedConfig.context,\n    id: `${sharedConfig.context.id}${sharedConfig.context.count++}-`,\n    count: 0\n  };\n}\n\nconst equalFn = (a, b) => a === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst $TRACK = Symbol(\"solid-track\");\nconst $DEVCOMP = Symbol(\"solid-dev-component\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet ERROR = null;\nlet runEffects = runQueue;\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst NO_INIT = {};\nvar Owner = null;\nlet Transition = null;\nlet Scheduler = null;\nlet ExternalSourceFactory = null;\nlet Listener = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nconst [transPending, setTransPending] = /*@__PURE__*/createSignal(false);\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener,\n    owner = Owner,\n    unowned = fn.length === 0,\n    root = unowned ? UNOWNED : {\n      owned: null,\n      cleanups: null,\n      context: null,\n      owner: detachedOwner === undefined ? owner : detachedOwner\n    },\n    updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(updateFn, true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    comparator: options.equals || undefined\n  };\n  const setter = value => {\n    if (typeof value === \"function\") {\n      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.tValue);else value = value(s.value);\n    }\n    return writeSignal(s, value);\n  };\n  return [readSignal.bind(s), setter];\n}\nfunction createComputed(fn, value, options) {\n  const c = createComputation(fn, value, true, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c = createComputation(fn, value, false, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false, STALE),\n    s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  if (!options || !options.render) c.user = true;\n  Effects ? Effects.push(c) : updateComputation(c);\n}\nfunction createReaction(onInvalidate, options) {\n  let fn;\n  const c = createComputation(() => {\n      fn ? fn() : untrack(onInvalidate);\n      fn = undefined;\n    }, undefined, false, 0),\n    s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  return tracking => {\n    fn = tracking;\n    updateComputation(c);\n  };\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true, 0);\n  c.observers = null;\n  c.observerSlots = null;\n  c.comparator = options.equals || undefined;\n  if (Scheduler && Transition && Transition.running) {\n    c.tState = STALE;\n    Updates.push(c);\n  } else updateComputation(c);\n  return readSignal.bind(c);\n}\nfunction createResource(pSource, pFetcher, pOptions) {\n  let source;\n  let fetcher;\n  let options;\n  if (arguments.length === 2 && typeof pFetcher === \"object\" || arguments.length === 1) {\n    source = true;\n    fetcher = pSource;\n    options = pFetcher || {};\n  } else {\n    source = pSource;\n    fetcher = pFetcher;\n    options = pOptions || {};\n  }\n  let pr = null,\n    initP = NO_INIT,\n    id = null,\n    loadedUnderTransition = false,\n    scheduled = false,\n    resolved = (\"initialValue\" in options),\n    dynamic = typeof source === \"function\" && createMemo(source);\n  const contexts = new Set(),\n    [value, setValue] = (options.storage || createSignal)(options.initialValue),\n    [error, setError] = createSignal(undefined),\n    [track, trigger] = createSignal(undefined, {\n      equals: false\n    }),\n    [state, setState] = createSignal(resolved ? \"ready\" : \"unresolved\");\n  if (sharedConfig.context) {\n    id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;\n    let v;\n    if (options.ssrLoadFrom === \"initial\") initP = options.initialValue;else if (sharedConfig.load && (v = sharedConfig.load(id))) initP = v[0];\n  }\n  function loadEnd(p, v, error, key) {\n    if (pr === p) {\n      pr = null;\n      resolved = true;\n      if ((p === initP || v === initP) && options.onHydrated) queueMicrotask(() => options.onHydrated(key, {\n        value: v\n      }));\n      initP = NO_INIT;\n      if (Transition && p && loadedUnderTransition) {\n        Transition.promises.delete(p);\n        loadedUnderTransition = false;\n        runUpdates(() => {\n          Transition.running = true;\n          completeLoad(v, error);\n        }, false);\n      } else completeLoad(v, error);\n    }\n    return v;\n  }\n  function completeLoad(v, err) {\n    runUpdates(() => {\n      if (err === undefined) setValue(() => v);\n      setState(err !== undefined ? \"errored\" : \"ready\");\n      setError(err);\n      for (const c of contexts.keys()) c.decrement();\n      contexts.clear();\n    }, false);\n  }\n  function read() {\n    const c = SuspenseContext && lookup(Owner, SuspenseContext.id),\n      v = value(),\n      err = error();\n    if (err !== undefined && !pr) throw err;\n    if (Listener && !Listener.user && c) {\n      createComputed(() => {\n        track();\n        if (pr) {\n          if (c.resolved && Transition && loadedUnderTransition) Transition.promises.add(pr);else if (!contexts.has(c)) {\n            c.increment();\n            contexts.add(c);\n          }\n        }\n      });\n    }\n    return v;\n  }\n  function load(refetching = true) {\n    if (refetching !== false && scheduled) return;\n    scheduled = false;\n    const lookup = dynamic ? dynamic() : source;\n    loadedUnderTransition = Transition && Transition.running;\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(value));\n      return;\n    }\n    if (Transition && pr) Transition.promises.delete(pr);\n    const p = initP !== NO_INIT ? initP : untrack(() => fetcher(lookup, {\n      value: value(),\n      refetching\n    }));\n    if (typeof p !== \"object\" || !(p && \"then\" in p)) {\n      loadEnd(pr, p, undefined, lookup);\n      return p;\n    }\n    pr = p;\n    scheduled = true;\n    queueMicrotask(() => scheduled = false);\n    runUpdates(() => {\n      setState(resolved ? \"refreshing\" : \"pending\");\n      trigger();\n    }, false);\n    return p.then(v => loadEnd(p, v, undefined, lookup), e => loadEnd(p, undefined, castError(e), lookup));\n  }\n  Object.defineProperties(read, {\n    state: {\n      get: () => state()\n    },\n    error: {\n      get: () => error()\n    },\n    loading: {\n      get() {\n        const s = state();\n        return s === \"pending\" || s === \"refreshing\";\n      }\n    },\n    latest: {\n      get() {\n        if (!resolved) return read();\n        const err = error();\n        if (err && !pr) throw err;\n        return value();\n      }\n    }\n  });\n  if (dynamic) createComputed(() => load(false));else load(false);\n  return [read, {\n    refetch: load,\n    mutate: setValue\n  }];\n}\nfunction createDeferred(source, options) {\n  let t,\n    timeout = options ? options.timeoutMs : undefined;\n  const node = createComputation(() => {\n    if (!t || !t.fn) t = requestCallback(() => setDeferred(() => node.value), timeout !== undefined ? {\n      timeout\n    } : undefined);\n    return source();\n  }, undefined, true);\n  const [deferred, setDeferred] = createSignal(node.value, options);\n  updateComputation(node);\n  setDeferred(() => node.value);\n  return deferred;\n}\nfunction createSelector(source, fn = equalFn, options) {\n  const subs = new Map();\n  const node = createComputation(p => {\n    const v = source();\n    for (const [key, val] of subs.entries()) if (fn(key, v) !== fn(key, p)) {\n      for (const c of val.values()) {\n        c.state = STALE;\n        if (c.pure) Updates.push(c);else Effects.push(c);\n      }\n    }\n    return v;\n  }, undefined, true, STALE);\n  updateComputation(node);\n  return key => {\n    const listener = Listener;\n    if (listener) {\n      let l;\n      if (l = subs.get(key)) l.add(listener);else subs.set(key, l = new Set([listener]));\n      onCleanup(() => {\n        l.delete(listener);\n        !l.size && subs.delete(key);\n      });\n    }\n    return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);\n  };\n}\nfunction batch(fn) {\n  return runUpdates(fn, false);\n}\nfunction untrack(fn) {\n  if (Listener === null) return fn();\n  const listener = Listener;\n  Listener = null;\n  try {\n    return fn();\n  } finally {\n    Listener = listener;\n  }\n}\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let defer = options && options.defer;\n  return prevValue => {\n    let input;\n    if (isArray) {\n      input = Array(deps.length);\n      for (let i = 0; i < deps.length; i++) input[i] = deps[i]();\n    } else input = deps();\n    if (defer) {\n      defer = false;\n      return undefined;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null) ;else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction catchError(fn, handler) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  Owner = createComputation(undefined, undefined, true);\n  Owner.context = {\n    [ERROR]: [handler]\n  };\n  if (Transition && Transition.running) Transition.sources.add(Owner);\n  try {\n    return fn();\n  } catch (err) {\n    handleError(err);\n  } finally {\n    Owner = Owner.owner;\n  }\n}\nfunction onError(fn) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  if (Owner === null) ;else if (Owner.context === null) Owner.context = {\n    [ERROR]: [fn]\n  };else if (!Owner.context[ERROR]) Owner.context[ERROR] = [fn];else Owner.context[ERROR].push(fn);\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction runWithOwner(o, fn) {\n  const prev = Owner;\n  const prevListener = Listener;\n  Owner = o;\n  Listener = null;\n  try {\n    return runUpdates(fn, true);\n  } catch (err) {\n    handleError(err);\n  } finally {\n    Owner = prev;\n    Listener = prevListener;\n  }\n}\nfunction enableScheduling(scheduler = requestCallback) {\n  Scheduler = scheduler;\n}\nfunction startTransition(fn) {\n  if (Transition && Transition.running) {\n    fn();\n    return Transition.done;\n  }\n  const l = Listener;\n  const o = Owner;\n  return Promise.resolve().then(() => {\n    Listener = l;\n    Owner = o;\n    let t;\n    if (Scheduler || SuspenseContext) {\n      t = Transition || (Transition = {\n        sources: new Set(),\n        effects: [],\n        promises: new Set(),\n        disposed: new Set(),\n        queue: new Set(),\n        running: true\n      });\n      t.done || (t.done = new Promise(res => t.resolve = res));\n      t.running = true;\n    }\n    runUpdates(fn, false);\n    Listener = Owner = null;\n    return t ? t.done : undefined;\n  });\n}\nfunction useTransition() {\n  return [transPending, startTransition];\n}\nfunction resumeEffects(e) {\n  Effects.push.apply(Effects, e);\n  e.length = 0;\n}\nfunction createContext(defaultValue, options) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  let ctx;\n  return (ctx = lookup(Owner, context.id)) !== undefined ? ctx : context.defaultValue;\n}\nfunction children(fn) {\n  const children = createMemo(fn);\n  const memo = createMemo(() => resolveChildren(children()));\n  memo.toArray = () => {\n    const c = memo();\n    return Array.isArray(c) ? c : c != null ? [c] : [];\n  };\n  return memo;\n}\nlet SuspenseContext;\nfunction getSuspenseContext() {\n  return SuspenseContext || (SuspenseContext = createContext({}));\n}\nfunction enableExternalSource(factory) {\n  if (ExternalSourceFactory) {\n    const oldFactory = ExternalSourceFactory;\n    ExternalSourceFactory = (fn, trigger) => {\n      const oldSource = oldFactory(fn, trigger);\n      const source = factory(x => oldSource.track(x), trigger);\n      return {\n        track: x => source.track(x),\n        dispose() {\n          source.dispose();\n          oldSource.dispose();\n        }\n      };\n    };\n  } else {\n    ExternalSourceFactory = factory;\n  }\n}\nfunction readSignal() {\n  const runningTransition = Transition && Transition.running;\n  if (this.sources && (runningTransition ? this.tState : this.state)) {\n    if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);else {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(this), false);\n      Updates = updates;\n    }\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  if (runningTransition && Transition.sources.has(this)) return this.tValue;\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;\n  if (!node.comparator || !node.comparator(current, value)) {\n    if (Transition) {\n      const TransitionRunning = Transition.running;\n      if (TransitionRunning || !isComp && Transition.sources.has(node)) {\n        Transition.sources.add(node);\n        node.tValue = value;\n      }\n      if (!TransitionRunning) node.value = value;\n    } else node.value = value;\n    if (node.observers && node.observers.length) {\n      runUpdates(() => {\n        for (let i = 0; i < node.observers.length; i += 1) {\n          const o = node.observers[i];\n          const TransitionRunning = Transition && Transition.running;\n          if (TransitionRunning && Transition.disposed.has(o)) continue;\n          if (TransitionRunning ? !o.tState : !o.state) {\n            if (o.pure) Updates.push(o);else Effects.push(o);\n            if (o.observers) markDownstream(o);\n          }\n          if (!TransitionRunning) o.state = STALE;else o.tState = STALE;\n        }\n        if (Updates.length > 10e5) {\n          Updates = [];\n          if (false) ;\n          throw new Error();\n        }\n      }, false);\n    }\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const owner = Owner,\n    listener = Listener,\n    time = ExecCount;\n  Listener = Owner = node;\n  runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);\n  if (Transition && !Transition.running && Transition.sources.has(node)) {\n    queueMicrotask(() => {\n      runUpdates(() => {\n        Transition && (Transition.running = true);\n        Listener = Owner = node;\n        runComputation(node, node.tValue, time);\n        Listener = Owner = null;\n      }, false);\n    });\n  }\n  Listener = listener;\n  Owner = owner;\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    if (node.pure) {\n      if (Transition && Transition.running) {\n        node.tState = STALE;\n        node.tOwned && node.tOwned.forEach(cleanNode);\n        node.tOwned = undefined;\n      } else {\n        node.state = STALE;\n        node.owned && node.owned.forEach(cleanNode);\n        node.owned = null;\n      }\n    }\n    node.updatedAt = time + 1;\n    return handleError(err);\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.updatedAt != null && \"observers\" in node) {\n      writeSignal(node, nextValue, true);\n    } else if (Transition && Transition.running && node.pure) {\n      Transition.sources.add(node);\n      node.tValue = nextValue;\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c = {\n    fn,\n    state: state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: null,\n    pure\n  };\n  if (Transition && Transition.running) {\n    c.state = 0;\n    c.tState = state;\n  }\n  if (Owner === null) ;else if (Owner !== UNOWNED) {\n    if (Transition && Transition.running && Owner.pure) {\n      if (!Owner.tOwned) Owner.tOwned = [c];else Owner.tOwned.push(c);\n    } else {\n      if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);\n    }\n  }\n  if (ExternalSourceFactory) {\n    const [track, trigger] = createSignal(undefined, {\n      equals: false\n    });\n    const ordinary = ExternalSourceFactory(c.fn, trigger);\n    onCleanup(() => ordinary.dispose());\n    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());\n    const inTransition = ExternalSourceFactory(c.fn, triggerInTransition);\n    c.fn = x => {\n      track();\n      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);\n    };\n  }\n  return c;\n}\nfunction runTop(node) {\n  const runningTransition = Transition && Transition.running;\n  if ((runningTransition ? node.tState : node.state) === 0) return;\n  if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (runningTransition && Transition.disposed.has(node)) return;\n    if (runningTransition ? node.tState : node.state) ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    node = ancestors[i];\n    if (runningTransition) {\n      let top = node,\n        prev = ancestors[i + 1];\n      while ((top = top.owner) && top !== prev) {\n        if (Transition.disposed.has(top)) return;\n      }\n    }\n    if ((runningTransition ? node.tState : node.state) === STALE) {\n      updateComputation(node);\n    } else if ((runningTransition ? node.tState : node.state) === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(node, ancestors[0]), false);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;else Effects = [];\n  ExecCount++;\n  try {\n    const res = fn();\n    completeUpdates(wait);\n    return res;\n  } catch (err) {\n    if (!wait) Effects = null;\n    Updates = null;\n    handleError(err);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);else runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  let res;\n  if (Transition) {\n    if (!Transition.promises.size && !Transition.queue.size) {\n      const sources = Transition.sources;\n      const disposed = Transition.disposed;\n      Effects.push.apply(Effects, Transition.effects);\n      res = Transition.resolve;\n      for (const e of Effects) {\n        \"tState\" in e && (e.state = e.tState);\n        delete e.tState;\n      }\n      Transition = null;\n      runUpdates(() => {\n        for (const d of disposed) cleanNode(d);\n        for (const v of sources) {\n          v.value = v.tValue;\n          if (v.owned) {\n            for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);\n          }\n          if (v.tOwned) v.owned = v.tOwned;\n          delete v.tValue;\n          delete v.tOwned;\n          v.tState = 0;\n        }\n        setTransPending(false);\n      }, false);\n    } else if (Transition.running) {\n      Transition.running = false;\n      Transition.effects.push.apply(Transition.effects, Effects);\n      Effects = null;\n      setTransPending(true);\n      return;\n    }\n  }\n  const e = Effects;\n  Effects = null;\n  if (e.length) runUpdates(() => runEffects(e), false);\n  if (res) res();\n}\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\nfunction scheduleQueue(queue) {\n  for (let i = 0; i < queue.length; i++) {\n    const item = queue[i];\n    const tasks = Transition.queue;\n    if (!tasks.has(item)) {\n      tasks.add(item);\n      Scheduler(() => {\n        tasks.delete(item);\n        runUpdates(() => {\n          Transition.running = true;\n          runTop(item);\n        }, false);\n        Transition && (Transition.running = false);\n      });\n    }\n  }\n}\nfunction runUserEffects(queue) {\n  let i,\n    userLength = 0;\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);else queue[userLength++] = e;\n  }\n  if (sharedConfig.context) setHydrateContext();\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n}\nfunction lookUpstream(node, ignore) {\n  const runningTransition = Transition && Transition.running;\n  if (runningTransition) node.tState = 0;else node.state = 0;\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n    if (source.sources) {\n      const state = runningTransition ? source.tState : source.state;\n      if (state === STALE) {\n        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);\n      } else if (state === PENDING) lookUpstream(source, ignore);\n    }\n  }\n}\nfunction markDownstream(node) {\n  const runningTransition = Transition && Transition.running;\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n    if (runningTransition ? !o.tState : !o.state) {\n      if (runningTransition) o.tState = PENDING;else o.state = PENDING;\n      if (o.pure) Updates.push(o);else Effects.push(o);\n      o.observers && markDownstream(o);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n        index = node.sourceSlots.pop(),\n        obs = source.observers;\n      if (obs && obs.length) {\n        const n = obs.pop(),\n          s = source.observerSlots.pop();\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n  if (Transition && Transition.running && node.pure) {\n    if (node.tOwned) {\n      for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);\n      delete node.tOwned;\n    }\n    reset(node, true);\n  } else if (node.owned) {\n    for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();\n    node.cleanups = null;\n  }\n  if (Transition && Transition.running) node.tState = 0;else node.state = 0;\n  node.context = null;\n}\nfunction reset(node, top) {\n  if (!top) {\n    node.tState = 0;\n    Transition.disposed.add(node);\n  }\n  if (node.owned) {\n    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);\n  }\n}\nfunction castError(err) {\n  if (err instanceof Error) return err;\n  return new Error(typeof err === \"string\" ? err : \"Unknown error\", {\n    cause: err\n  });\n}\nfunction runErrors(fns, err) {\n  for (const f of fns) f(err);\n}\nfunction handleError(err) {\n  const fns = ERROR && lookup(Owner, ERROR);\n  if (!fns) throw err;\n  const error = castError(err);\n  if (Effects) Effects.push({\n    fn() {\n      runErrors(fns, error);\n    },\n    state: STALE\n  });else runErrors(fns, error);\n}\nfunction lookup(owner, key) {\n  return owner ? owner.context && owner.context[key] !== undefined ? owner.context[key] : lookup(owner.owner, key) : undefined;\n}\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n  if (Array.isArray(children)) {\n    const results = [];\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children;\n}\nfunction createProvider(id, options) {\n  return function provider(props) {\n    let res;\n    createRenderEffect(() => res = untrack(() => {\n      Owner.context = {\n        [id]: props.value\n      };\n      return children(() => props.children);\n    }), undefined);\n    return res;\n  };\n}\n\nfunction observable(input) {\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError(\"Expected the observer to be an object.\");\n      }\n      const handler = typeof observer === \"function\" ? observer : observer.next && observer.next.bind(observer);\n      if (!handler) {\n        return {\n          unsubscribe() {}\n        };\n      }\n      const dispose = createRoot(disposer => {\n        createEffect(() => {\n          const v = input();\n          untrack(() => handler(v));\n        });\n        return disposer;\n      });\n      if (getOwner()) onCleanup(dispose);\n      return {\n        unsubscribe() {\n          dispose();\n        }\n      };\n    },\n    [Symbol.observable || \"@@observable\"]() {\n      return this;\n    }\n  };\n}\nfunction from(producer) {\n  const [s, set] = createSignal(undefined, {\n    equals: false\n  });\n  if (\"subscribe\" in producer) {\n    const unsub = producer.subscribe(v => set(() => v));\n    onCleanup(() => \"unsubscribe\" in unsub ? unsub.unsubscribe() : unsub());\n  } else {\n    const clean = producer(set);\n    onCleanup(clean);\n  }\n  return s;\n}\n\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [],\n    mapped = [],\n    disposers = [],\n    len = 0,\n    indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n      i,\n      j;\n    newItems[$TRACK];\n    return untrack(() => {\n      let newLen = newItems.length,\n        newIndices,\n        newIndicesNext,\n        temp,\n        tempdisposers,\n        tempIndexes,\n        start,\n        end,\n        newEnd,\n        item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      }\n      else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);\n        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i = newIndices.get(item);\n          newIndicesNext[j] = i === undefined ? -1 : i;\n          newIndices.set(item, j);\n        }\n        for (i = start; i <= end; i++) {\n          item = items[i];\n          j = newIndices.get(item);\n          if (j !== undefined && j !== -1) {\n            temp[j] = mapped[i];\n            tempdisposers[j] = disposers[i];\n            indexes && (tempIndexes[j] = indexes[i]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, len = newLen);\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction indexArray(list, mapFn, options = {}) {\n  let items = [],\n    mapped = [],\n    disposers = [],\n    signals = [],\n    len = 0,\n    i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [];\n    newItems[$TRACK];\n    return untrack(() => {\n      if (newItems.length === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n        return mapped;\n      }\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n      for (i = 0; i < newItems.length; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n      len = signals.length = disposers.length = newItems.length;\n      items = newItems.slice(0);\n      return mapped = mapped.slice(0, len);\n    });\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i]);\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\n\nlet hydrationEnabled = false;\nfunction enableHydration() {\n  hydrationEnabled = true;\n}\nfunction createComponent(Comp, props) {\n  if (hydrationEnabled) {\n    if (sharedConfig.context) {\n      const c = sharedConfig.context;\n      setHydrateContext(nextHydrateContext());\n      const r = untrack(() => Comp(props || {}));\n      setHydrateContext(c);\n      return r;\n    }\n  }\n  return untrack(() => Comp(props || {}));\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    if (property === $PROXY) return true;\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s) {\n  return !(s = typeof s === \"function\" ? s() : s) ? {} : s;\n}\nfunction mergeProps(...sources) {\n  let proxy = false;\n  for (let i = 0; i < sources.length; i++) {\n    const s = sources[i];\n    proxy = proxy || !!s && $PROXY in s;\n    sources[i] = typeof s === \"function\" ? (proxy = true, createMemo(s)) : s;\n  }\n  if (proxy) {\n    return new Proxy({\n      get(property) {\n        for (let i = sources.length - 1; i >= 0; i--) {\n          const v = resolveSource(sources[i])[property];\n          if (v !== undefined) return v;\n        }\n      },\n      has(property) {\n        for (let i = sources.length - 1; i >= 0; i--) {\n          if (property in resolveSource(sources[i])) return true;\n        }\n        return false;\n      },\n      keys() {\n        const keys = [];\n        for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));\n        return [...new Set(keys)];\n      }\n    }, propTraps);\n  }\n  const target = {};\n  for (let i = sources.length - 1; i >= 0; i--) {\n    if (sources[i]) {\n      const descriptors = Object.getOwnPropertyDescriptors(sources[i]);\n      for (const key in descriptors) {\n        if (key in target) continue;\n        Object.defineProperty(target, key, {\n          enumerable: true,\n          get() {\n            for (let i = sources.length - 1; i >= 0; i--) {\n              const v = (sources[i] || {})[key];\n              if (v !== undefined) return v;\n            }\n          }\n        });\n      }\n    }\n  }\n  return target;\n}\nfunction splitProps(props, ...keys) {\n  const blocked = new Set(keys.flat());\n  if ($PROXY in props) {\n    const res = keys.map(k => {\n      return new Proxy({\n        get(property) {\n          return k.includes(property) ? props[property] : undefined;\n        },\n        has(property) {\n          return k.includes(property) && property in props;\n        },\n        keys() {\n          return k.filter(property => property in props);\n        }\n      }, propTraps);\n    });\n    res.push(new Proxy({\n      get(property) {\n        return blocked.has(property) ? undefined : props[property];\n      },\n      has(property) {\n        return blocked.has(property) ? false : property in props;\n      },\n      keys() {\n        return Object.keys(props).filter(k => !blocked.has(k));\n      }\n    }, propTraps));\n    return res;\n  }\n  const descriptors = Object.getOwnPropertyDescriptors(props);\n  keys.push(Object.keys(descriptors).filter(k => !blocked.has(k)));\n  return keys.map(k => {\n    const clone = {};\n    for (let i = 0; i < k.length; i++) {\n      const key = k[i];\n      if (!(key in props)) continue;\n      Object.defineProperty(clone, key, descriptors[key] ? descriptors[key] : {\n        get() {\n          return props[key];\n        },\n        set() {\n          return true;\n        },\n        enumerable: true\n      });\n    }\n    return clone;\n  });\n}\nfunction lazy(fn) {\n  let comp;\n  let p;\n  const wrap = props => {\n    const ctx = sharedConfig.context;\n    if (ctx) {\n      const [s, set] = createSignal();\n      (p || (p = fn())).then(mod => {\n        setHydrateContext(ctx);\n        set(() => mod.default);\n        setHydrateContext();\n      });\n      comp = s;\n    } else if (!comp) {\n      const [s] = createResource(() => (p || (p = fn())).then(mod => mod.default));\n      comp = s;\n    }\n    let Comp;\n    return createMemo(() => (Comp = comp()) && untrack(() => {\n      if (false) ;\n      if (!ctx) return Comp(props);\n      const c = sharedConfig.context;\n      setHydrateContext(ctx);\n      const r = Comp(props);\n      setHydrateContext(c);\n      return r;\n    }));\n  };\n  wrap.preload = () => p || ((p = fn()).then(mod => comp = () => mod.default), p);\n  return wrap;\n}\nlet counter = 0;\nfunction createUniqueId() {\n  const ctx = sharedConfig.context;\n  return ctx ? `${ctx.id}${ctx.count++}` : `cl-${counter++}`;\n}\n\nconst narrowedError = name => `Stale read from <${name}>.`;\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback || undefined));\n}\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(indexArray(() => props.each, props.children, fallback || undefined));\n}\nfunction Show(props) {\n  const keyed = props.keyed;\n  const condition = createMemo(() => props.when, undefined, {\n    equals: (a, b) => keyed ? a === b : !a === !b\n  });\n  return createMemo(() => {\n    const c = condition();\n    if (c) {\n      const child = props.children;\n      const fn = typeof child === \"function\" && child.length > 0;\n      return fn ? untrack(() => child(keyed ? c : () => {\n        if (!untrack(condition)) throw narrowedError(\"Show\");\n        return props.when;\n      })) : child;\n    }\n    return props.fallback;\n  }, undefined, undefined);\n}\nfunction Switch(props) {\n  let keyed = false;\n  const equals = (a, b) => a[0] === b[0] && (keyed ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2];\n  const conditions = children(() => props.children),\n    evalConditions = createMemo(() => {\n      let conds = conditions();\n      if (!Array.isArray(conds)) conds = [conds];\n      for (let i = 0; i < conds.length; i++) {\n        const c = conds[i].when;\n        if (c) {\n          keyed = !!conds[i].keyed;\n          return [i, c, conds[i]];\n        }\n      }\n      return [-1];\n    }, undefined, {\n      equals\n    });\n  return createMemo(() => {\n    const [index, when, cond] = evalConditions();\n    if (index < 0) return props.fallback;\n    const c = cond.children;\n    const fn = typeof c === \"function\" && c.length > 0;\n    return fn ? untrack(() => c(keyed ? when : () => {\n      if (untrack(evalConditions)[0] !== index) throw narrowedError(\"Match\");\n      return cond.when;\n    })) : c;\n  }, undefined, undefined);\n}\nfunction Match(props) {\n  return props;\n}\nlet Errors;\nfunction resetErrorBoundaries() {\n  Errors && [...Errors].forEach(fn => fn());\n}\nfunction ErrorBoundary(props) {\n  let err;\n  let v;\n  if (sharedConfig.context && sharedConfig.load && (v = sharedConfig.load(sharedConfig.context.id + sharedConfig.context.count))) err = v[0];\n  const [errored, setErrored] = createSignal(err, undefined);\n  Errors || (Errors = new Set());\n  Errors.add(setErrored);\n  onCleanup(() => Errors.delete(setErrored));\n  return createMemo(() => {\n    let e;\n    if (e = errored()) {\n      const f = props.fallback;\n      return typeof f === \"function\" && f.length ? untrack(() => f(e, () => setErrored())) : f;\n    }\n    return catchError(() => props.children, setErrored);\n  }, undefined, undefined);\n}\n\nconst suspenseListEquals = (a, b) => a.showContent === b.showContent && a.showFallback === b.showFallback;\nconst SuspenseListContext = createContext();\nfunction SuspenseList(props) {\n  let [wrapper, setWrapper] = createSignal(() => ({\n      inFallback: false\n    })),\n    show;\n  const listContext = useContext(SuspenseListContext);\n  const [registry, setRegistry] = createSignal([]);\n  if (listContext) {\n    show = listContext.register(createMemo(() => wrapper()().inFallback));\n  }\n  const resolved = createMemo(prev => {\n    const reveal = props.revealOrder,\n      tail = props.tail,\n      {\n        showContent = true,\n        showFallback = true\n      } = show ? show() : {},\n      reg = registry(),\n      reverse = reveal === \"backwards\";\n    if (reveal === \"together\") {\n      const all = reg.every(inFallback => !inFallback());\n      const res = reg.map(() => ({\n        showContent: all && showContent,\n        showFallback\n      }));\n      res.inFallback = !all;\n      return res;\n    }\n    let stop = false;\n    let inFallback = prev.inFallback;\n    const res = [];\n    for (let i = 0, len = reg.length; i < len; i++) {\n      const n = reverse ? len - i - 1 : i,\n        s = reg[n]();\n      if (!stop && !s) {\n        res[n] = {\n          showContent,\n          showFallback\n        };\n      } else {\n        const next = !stop;\n        if (next) inFallback = true;\n        res[n] = {\n          showContent: next,\n          showFallback: !tail || next && tail === \"collapsed\" ? showFallback : false\n        };\n        stop = true;\n      }\n    }\n    if (!stop) inFallback = false;\n    res.inFallback = inFallback;\n    return res;\n  }, {\n    inFallback: false\n  });\n  setWrapper(() => resolved);\n  return createComponent(SuspenseListContext.Provider, {\n    value: {\n      register: inFallback => {\n        let index;\n        setRegistry(registry => {\n          index = registry.length;\n          return [...registry, inFallback];\n        });\n        return createMemo(() => resolved()[index], undefined, {\n          equals: suspenseListEquals\n        });\n      }\n    },\n    get children() {\n      return props.children;\n    }\n  });\n}\nfunction Suspense(props) {\n  let counter = 0,\n    show,\n    ctx,\n    p,\n    flicker,\n    error;\n  const [inFallback, setFallback] = createSignal(false),\n    SuspenseContext = getSuspenseContext(),\n    store = {\n      increment: () => {\n        if (++counter === 1) setFallback(true);\n      },\n      decrement: () => {\n        if (--counter === 0) setFallback(false);\n      },\n      inFallback,\n      effects: [],\n      resolved: false\n    },\n    owner = getOwner();\n  if (sharedConfig.context && sharedConfig.load) {\n    const key = sharedConfig.context.id + sharedConfig.context.count;\n    let ref = sharedConfig.load(key);\n    if (ref && (p = ref[0]) && p !== \"$$f\") {\n      if (typeof p !== \"object\" || !(\"then\" in p)) p = Promise.resolve(p);\n      const [s, set] = createSignal(undefined, {\n        equals: false\n      });\n      flicker = s;\n      p.then(err => {\n        if (err || sharedConfig.done) {\n          err && (error = err);\n          return set();\n        }\n        sharedConfig.gather(key);\n        setHydrateContext(ctx);\n        set();\n        setHydrateContext();\n      });\n    }\n  }\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) show = listContext.register(store.inFallback);\n  let dispose;\n  onCleanup(() => dispose && dispose());\n  return createComponent(SuspenseContext.Provider, {\n    value: store,\n    get children() {\n      return createMemo(() => {\n        if (error) throw error;\n        ctx = sharedConfig.context;\n        if (flicker) {\n          flicker();\n          return flicker = undefined;\n        }\n        if (ctx && p === \"$$f\") setHydrateContext();\n        const rendered = createMemo(() => props.children);\n        return createMemo(prev => {\n          const inFallback = store.inFallback(),\n            {\n              showContent = true,\n              showFallback = true\n            } = show ? show() : {};\n          if ((!inFallback || p && p !== \"$$f\") && showContent) {\n            store.resolved = true;\n            dispose && dispose();\n            dispose = ctx = p = undefined;\n            resumeEffects(store.effects);\n            return rendered();\n          }\n          if (!showFallback) return;\n          if (dispose) return prev;\n          return createRoot(disposer => {\n            dispose = disposer;\n            if (ctx) {\n              setHydrateContext({\n                id: ctx.id + \"f\",\n                count: 0\n              });\n              ctx = undefined;\n            }\n            return props.fallback;\n          }, owner);\n        });\n      });\n    }\n  });\n}\n\nconst DEV = undefined;\n\nexport { $DEVCOMP, $PROXY, $TRACK, DEV, ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, batch, cancelCallback, catchError, children, createComponent, createComputed, createContext, createDeferred, createEffect, createMemo, createReaction, createRenderEffect, createResource, createRoot, createSelector, createSignal, createUniqueId, enableExternalSource, enableHydration, enableScheduling, equalFn, from, getListener, getOwner, indexArray, lazy, mapArray, mergeProps, observable, on, onCleanup, onError, onMount, requestCallback, resetErrorBoundaries, runWithOwner, sharedConfig, splitProps, startTransition, untrack, useContext, useTransition };\n","import { createRoot, createRenderEffect, sharedConfig, untrack, enableHydration, getOwner, createEffect, runWithOwner, createSignal, onCleanup, splitProps, createMemo, $DEVCOMP } from 'solid-js';\nexport { ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, createComponent, createRenderEffect as effect, getOwner, createMemo as memo, mergeProps, untrack } from 'solid-js';\n\nconst booleans = [\"allowfullscreen\", \"async\", \"autofocus\", \"autoplay\", \"checked\", \"controls\", \"default\", \"disabled\", \"formnovalidate\", \"hidden\", \"indeterminate\", \"ismap\", \"loop\", \"multiple\", \"muted\", \"nomodule\", \"novalidate\", \"open\", \"playsinline\", \"readonly\", \"required\", \"reversed\", \"seamless\", \"selected\"];\nconst Properties = /*#__PURE__*/new Set([\"className\", \"value\", \"readOnly\", \"formNoValidate\", \"isMap\", \"noModule\", \"playsInline\", ...booleans]);\nconst ChildProperties = /*#__PURE__*/new Set([\"innerHTML\", \"textContent\", \"innerText\", \"children\"]);\nconst Aliases = /*#__PURE__*/Object.assign(Object.create(null), {\n  className: \"class\",\n  htmlFor: \"for\"\n});\nconst PropAliases = /*#__PURE__*/Object.assign(Object.create(null), {\n  class: \"className\",\n  formnovalidate: {\n    $: \"formNoValidate\",\n    BUTTON: 1,\n    INPUT: 1\n  },\n  ismap: {\n    $: \"isMap\",\n    IMG: 1\n  },\n  nomodule: {\n    $: \"noModule\",\n    SCRIPT: 1\n  },\n  playsinline: {\n    $: \"playsInline\",\n    VIDEO: 1\n  },\n  readonly: {\n    $: \"readOnly\",\n    INPUT: 1,\n    TEXTAREA: 1\n  }\n});\nfunction getPropAlias(prop, tagName) {\n  const a = PropAliases[prop];\n  return typeof a === \"object\" ? a[tagName] ? a[\"$\"] : undefined : a;\n}\nconst DelegatedEvents = /*#__PURE__*/new Set([\"beforeinput\", \"click\", \"dblclick\", \"contextmenu\", \"focusin\", \"focusout\", \"input\", \"keydown\", \"keyup\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\", \"mouseup\", \"pointerdown\", \"pointermove\", \"pointerout\", \"pointerover\", \"pointerup\", \"touchend\", \"touchmove\", \"touchstart\"]);\nconst SVGElements = /*#__PURE__*/new Set([\n\"altGlyph\", \"altGlyphDef\", \"altGlyphItem\", \"animate\", \"animateColor\", \"animateMotion\", \"animateTransform\", \"circle\", \"clipPath\", \"color-profile\", \"cursor\", \"defs\", \"desc\", \"ellipse\", \"feBlend\", \"feColorMatrix\", \"feComponentTransfer\", \"feComposite\", \"feConvolveMatrix\", \"feDiffuseLighting\", \"feDisplacementMap\", \"feDistantLight\", \"feFlood\", \"feFuncA\", \"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feImage\", \"feMerge\", \"feMergeNode\", \"feMorphology\", \"feOffset\", \"fePointLight\", \"feSpecularLighting\", \"feSpotLight\", \"feTile\", \"feTurbulence\", \"filter\", \"font\", \"font-face\", \"font-face-format\", \"font-face-name\", \"font-face-src\", \"font-face-uri\", \"foreignObject\", \"g\", \"glyph\", \"glyphRef\", \"hkern\", \"image\", \"line\", \"linearGradient\", \"marker\", \"mask\", \"metadata\", \"missing-glyph\", \"mpath\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"radialGradient\", \"rect\",\n\"set\", \"stop\",\n\"svg\", \"switch\", \"symbol\", \"text\", \"textPath\",\n\"tref\", \"tspan\", \"use\", \"view\", \"vkern\"]);\nconst SVGNamespace = {\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\"\n};\nconst DOMElements = /*#__PURE__*/new Set([\"html\", \"base\", \"head\", \"link\", \"meta\", \"style\", \"title\", \"body\", \"address\", \"article\", \"aside\", \"footer\", \"header\", \"main\", \"nav\", \"section\", \"body\", \"blockquote\", \"dd\", \"div\", \"dl\", \"dt\", \"figcaption\", \"figure\", \"hr\", \"li\", \"ol\", \"p\", \"pre\", \"ul\", \"a\", \"abbr\", \"b\", \"bdi\", \"bdo\", \"br\", \"cite\", \"code\", \"data\", \"dfn\", \"em\", \"i\", \"kbd\", \"mark\", \"q\", \"rp\", \"rt\", \"ruby\", \"s\", \"samp\", \"small\", \"span\", \"strong\", \"sub\", \"sup\", \"time\", \"u\", \"var\", \"wbr\", \"area\", \"audio\", \"img\", \"map\", \"track\", \"video\", \"embed\", \"iframe\", \"object\", \"param\", \"picture\", \"portal\", \"source\", \"svg\", \"math\", \"canvas\", \"noscript\", \"script\", \"del\", \"ins\", \"caption\", \"col\", \"colgroup\", \"table\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\", \"button\", \"datalist\", \"fieldset\", \"form\", \"input\", \"label\", \"legend\", \"meter\", \"optgroup\", \"option\", \"output\", \"progress\", \"select\", \"textarea\", \"details\", \"dialog\", \"menu\", \"summary\", \"details\", \"slot\", \"template\", \"acronym\", \"applet\", \"basefont\", \"bgsound\", \"big\", \"blink\", \"center\", \"content\", \"dir\", \"font\", \"frame\", \"frameset\", \"hgroup\", \"image\", \"keygen\", \"marquee\", \"menuitem\", \"nobr\", \"noembed\", \"noframes\", \"plaintext\", \"rb\", \"rtc\", \"shadow\", \"spacer\", \"strike\", \"tt\", \"xmp\", \"a\", \"abbr\", \"acronym\", \"address\", \"applet\", \"area\", \"article\", \"aside\", \"audio\", \"b\", \"base\", \"basefont\", \"bdi\", \"bdo\", \"bgsound\", \"big\", \"blink\", \"blockquote\", \"body\", \"br\", \"button\", \"canvas\", \"caption\", \"center\", \"cite\", \"code\", \"col\", \"colgroup\", \"content\", \"data\", \"datalist\", \"dd\", \"del\", \"details\", \"dfn\", \"dialog\", \"dir\", \"div\", \"dl\", \"dt\", \"em\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\", \"form\", \"frame\", \"frameset\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"iframe\", \"image\", \"img\", \"input\", \"ins\", \"kbd\", \"keygen\", \"label\", \"legend\", \"li\", \"link\", \"main\", \"map\", \"mark\", \"marquee\", \"menu\", \"menuitem\", \"meta\", \"meter\", \"nav\", \"nobr\", \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"param\", \"picture\", \"plaintext\", \"portal\", \"pre\", \"progress\", \"q\", \"rb\", \"rp\", \"rt\", \"rtc\", \"ruby\", \"s\", \"samp\", \"script\", \"section\", \"select\", \"shadow\", \"slot\", \"small\", \"source\", \"spacer\", \"span\", \"strike\", \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"time\", \"title\", \"tr\", \"track\", \"tt\", \"u\", \"ul\", \"var\", \"video\", \"wbr\", \"xmp\", \"input\"]);\n\nfunction reconcileArrays(parentNode, a, b) {\n  let bLength = b.length,\n    aEnd = a.length,\n    bEnd = bLength,\n    aStart = 0,\n    bStart = 0,\n    after = a[aEnd - 1].nextSibling,\n    map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n      continue;\n    }\n    while (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    if (aEnd === aStart) {\n      const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;\n      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);\n    } else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        if (!map || !map.has(a[aStart])) a[aStart].remove();\n        aStart++;\n      }\n    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      const node = a[--aEnd].nextSibling;\n      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);\n      parentNode.insertBefore(b[--bEnd], node);\n      a[aEnd] = b[bEnd];\n    } else {\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n        while (i < bEnd) map.set(b[i], i++);\n      }\n      const index = map.get(a[aStart]);\n      if (index != null) {\n        if (bStart < index && index < bEnd) {\n          let i = aStart,\n            sequence = 1,\n            t;\n          while (++i < aEnd && i < bEnd) {\n            if ((t = map.get(a[i])) == null || t !== index + sequence) break;\n            sequence++;\n          }\n          if (sequence > index - bStart) {\n            const node = a[aStart];\n            while (bStart < index) parentNode.insertBefore(b[bStart++], node);\n          } else parentNode.replaceChild(b[bStart++], a[aStart++]);\n        } else aStart++;\n      } else a[aStart++].remove();\n    }\n  }\n}\n\nconst $$EVENTS = \"_$DX_DELEGATE\";\nfunction render(code, element, init, options = {}) {\n  let disposer;\n  createRoot(dispose => {\n    disposer = dispose;\n    element === document ? code() : insert(element, code(), element.firstChild ? null : undefined, init);\n  }, options.owner);\n  return () => {\n    disposer();\n    element.textContent = \"\";\n  };\n}\nfunction template(html, isCE, isSVG) {\n  let node;\n  const create = () => {\n    const t = document.createElement(\"template\");\n    t.innerHTML = html;\n    return isSVG ? t.content.firstChild.firstChild : t.content.firstChild;\n  };\n  const fn = isCE ? () => (node || (node = create())).cloneNode(true) : () => untrack(() => document.importNode(node || (node = create()), true));\n  fn.cloneNode = fn;\n  return fn;\n}\nfunction delegateEvents(eventNames, document = window.document) {\n  const e = document[$$EVENTS] || (document[$$EVENTS] = new Set());\n  for (let i = 0, l = eventNames.length; i < l; i++) {\n    const name = eventNames[i];\n    if (!e.has(name)) {\n      e.add(name);\n      document.addEventListener(name, eventHandler);\n    }\n  }\n}\nfunction clearDelegatedEvents(document = window.document) {\n  if (document[$$EVENTS]) {\n    for (let name of document[$$EVENTS].keys()) document.removeEventListener(name, eventHandler);\n    delete document[$$EVENTS];\n  }\n}\nfunction setAttribute(node, name, value) {\n  if (value == null) node.removeAttribute(name);else node.setAttribute(name, value);\n}\nfunction setAttributeNS(node, namespace, name, value) {\n  if (value == null) node.removeAttributeNS(namespace, name);else node.setAttributeNS(namespace, name, value);\n}\nfunction className(node, value) {\n  if (value == null) node.removeAttribute(\"class\");else node.className = value;\n}\nfunction addEventListener(node, name, handler, delegate) {\n  if (delegate) {\n    if (Array.isArray(handler)) {\n      node[`$$${name}`] = handler[0];\n      node[`$$${name}Data`] = handler[1];\n    } else node[`$$${name}`] = handler;\n  } else if (Array.isArray(handler)) {\n    const handlerFn = handler[0];\n    node.addEventListener(name, handler[0] = e => handlerFn.call(node, handler[1], e));\n  } else node.addEventListener(name, handler);\n}\nfunction classList(node, value, prev = {}) {\n  const classKeys = Object.keys(value || {}),\n    prevKeys = Object.keys(prev);\n  let i, len;\n  for (i = 0, len = prevKeys.length; i < len; i++) {\n    const key = prevKeys[i];\n    if (!key || key === \"undefined\" || value[key]) continue;\n    toggleClassKey(node, key, false);\n    delete prev[key];\n  }\n  for (i = 0, len = classKeys.length; i < len; i++) {\n    const key = classKeys[i],\n      classValue = !!value[key];\n    if (!key || key === \"undefined\" || prev[key] === classValue || !classValue) continue;\n    toggleClassKey(node, key, true);\n    prev[key] = classValue;\n  }\n  return prev;\n}\nfunction style(node, value, prev) {\n  if (!value) return prev ? setAttribute(node, \"style\") : value;\n  const nodeStyle = node.style;\n  if (typeof value === \"string\") return nodeStyle.cssText = value;\n  typeof prev === \"string\" && (nodeStyle.cssText = prev = undefined);\n  prev || (prev = {});\n  value || (value = {});\n  let v, s;\n  for (s in prev) {\n    value[s] == null && nodeStyle.removeProperty(s);\n    delete prev[s];\n  }\n  for (s in value) {\n    v = value[s];\n    if (v !== prev[s]) {\n      nodeStyle.setProperty(s, v);\n      prev[s] = v;\n    }\n  }\n  return prev;\n}\nfunction spread(node, props = {}, isSVG, skipChildren) {\n  const prevProps = {};\n  if (!skipChildren) {\n    createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));\n  }\n  createRenderEffect(() => props.ref && props.ref(node));\n  createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));\n  return prevProps;\n}\nfunction dynamicProperty(props, key) {\n  const src = props[key];\n  Object.defineProperty(props, key, {\n    get() {\n      return src();\n    },\n    enumerable: true\n  });\n  return props;\n}\nfunction innerHTML(parent, content) {\n  !sharedConfig.context && (parent.innerHTML = content);\n}\nfunction use(fn, element, arg) {\n  return untrack(() => fn(element, arg));\n}\nfunction insert(parent, accessor, marker, initial) {\n  if (marker !== undefined && !initial) initial = [];\n  if (typeof accessor !== \"function\") return insertExpression(parent, accessor, initial, marker);\n  createRenderEffect(current => insertExpression(parent, accessor(), current, marker), initial);\n}\nfunction assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {\n  props || (props = {});\n  for (const prop in prevProps) {\n    if (!(prop in props)) {\n      if (prop === \"children\") continue;\n      prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef);\n    }\n  }\n  for (const prop in props) {\n    if (prop === \"children\") {\n      if (!skipChildren) insertExpression(node, props.children);\n      continue;\n    }\n    const value = props[prop];\n    prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef);\n  }\n}\nfunction hydrate$1(code, element, options = {}) {\n  sharedConfig.completed = globalThis._$HY.completed;\n  sharedConfig.events = globalThis._$HY.events;\n  sharedConfig.load = globalThis._$HY.load;\n  sharedConfig.gather = root => gatherHydratable(element, root);\n  sharedConfig.registry = new Map();\n  sharedConfig.context = {\n    id: options.renderId || \"\",\n    count: 0\n  };\n  gatherHydratable(element, options.renderId);\n  const dispose = render(code, element, [...element.childNodes], options);\n  sharedConfig.context = null;\n  return dispose;\n}\nfunction getNextElement(template) {\n  let node, key;\n  if (!sharedConfig.context || !(node = sharedConfig.registry.get(key = getHydrationKey()))) {\n    if (sharedConfig.context) console.warn(\"Unable to find DOM nodes for hydration key:\", key);\n    if (!template) throw new Error(\"Unrecoverable Hydration Mismatch. No template for key: \" + key);\n    return template();\n  }\n  if (sharedConfig.completed) sharedConfig.completed.add(node);\n  sharedConfig.registry.delete(key);\n  return node;\n}\nfunction getNextMatch(el, nodeName) {\n  while (el && el.localName !== nodeName) el = el.nextSibling;\n  return el;\n}\nfunction getNextMarker(start) {\n  let end = start,\n    count = 0,\n    current = [];\n  if (sharedConfig.context) {\n    while (end) {\n      if (end.nodeType === 8) {\n        const v = end.nodeValue;\n        if (v === \"#\") count++;else if (v === \"/\") {\n          if (count === 0) return [end, current];\n          count--;\n        }\n      }\n      current.push(end);\n      end = end.nextSibling;\n    }\n  }\n  return [end, current];\n}\nfunction runHydrationEvents() {\n  if (sharedConfig.events && !sharedConfig.events.queued) {\n    queueMicrotask(() => {\n      const {\n        completed,\n        events\n      } = sharedConfig;\n      events.queued = false;\n      while (events.length) {\n        const [el, e] = events[0];\n        if (!completed.has(el)) return;\n        eventHandler(e);\n        events.shift();\n      }\n    });\n    sharedConfig.events.queued = true;\n  }\n}\nfunction toPropertyName(name) {\n  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());\n}\nfunction toggleClassKey(node, key, value) {\n  const classNames = key.trim().split(/\\s+/);\n  for (let i = 0, nameLen = classNames.length; i < nameLen; i++) node.classList.toggle(classNames[i], value);\n}\nfunction assignProp(node, prop, value, prev, isSVG, skipRef) {\n  let isCE, isProp, isChildProp, propAlias, forceProp;\n  if (prop === \"style\") return style(node, value, prev);\n  if (prop === \"classList\") return classList(node, value, prev);\n  if (value === prev) return prev;\n  if (prop === \"ref\") {\n    if (!skipRef) value(node);\n  } else if (prop.slice(0, 3) === \"on:\") {\n    const e = prop.slice(3);\n    prev && node.removeEventListener(e, prev);\n    value && node.addEventListener(e, value);\n  } else if (prop.slice(0, 10) === \"oncapture:\") {\n    const e = prop.slice(10);\n    prev && node.removeEventListener(e, prev, true);\n    value && node.addEventListener(e, value, true);\n  } else if (prop.slice(0, 2) === \"on\") {\n    const name = prop.slice(2).toLowerCase();\n    const delegate = DelegatedEvents.has(name);\n    if (!delegate && prev) {\n      const h = Array.isArray(prev) ? prev[0] : prev;\n      node.removeEventListener(name, h);\n    }\n    if (delegate || value) {\n      addEventListener(node, name, value, delegate);\n      delegate && delegateEvents([name]);\n    }\n  } else if (prop.slice(0, 5) === \"attr:\") {\n    setAttribute(node, prop.slice(5), value);\n  } else if ((forceProp = prop.slice(0, 5) === \"prop:\") || (isChildProp = ChildProperties.has(prop)) || !isSVG && ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes(\"-\"))) {\n    if (forceProp) {\n      prop = prop.slice(5);\n      isProp = true;\n    }\n    if (prop === \"class\" || prop === \"className\") className(node, value);else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;else node[propAlias || prop] = value;\n  } else {\n    const ns = isSVG && prop.indexOf(\":\") > -1 && SVGNamespace[prop.split(\":\")[0]];\n    if (ns) setAttributeNS(node, ns, prop, value);else setAttribute(node, Aliases[prop] || prop, value);\n  }\n  return value;\n}\nfunction eventHandler(e) {\n  const key = `$$${e.type}`;\n  let node = e.composedPath && e.composedPath()[0] || e.target;\n  if (e.target !== node) {\n    Object.defineProperty(e, \"target\", {\n      configurable: true,\n      value: node\n    });\n  }\n  Object.defineProperty(e, \"currentTarget\", {\n    configurable: true,\n    get() {\n      return node || document;\n    }\n  });\n  if (sharedConfig.registry && !sharedConfig.done) sharedConfig.done = _$HY.done = true;\n  while (node) {\n    const handler = node[key];\n    if (handler && !node.disabled) {\n      const data = node[`${key}Data`];\n      data !== undefined ? handler.call(node, data, e) : handler.call(node, e);\n      if (e.cancelBubble) return;\n    }\n    node = node._$host || node.parentNode || node.host;\n  }\n}\nfunction insertExpression(parent, value, current, marker, unwrapArray) {\n  if (sharedConfig.context) {\n    !current && (current = [...parent.childNodes]);\n    let cleaned = [];\n    for (let i = 0; i < current.length; i++) {\n      const node = current[i];\n      if (node.nodeType === 8 && node.data.slice(0, 2) === \"!$\") node.remove();else cleaned.push(node);\n    }\n    current = cleaned;\n  }\n  while (typeof current === \"function\") current = current();\n  if (value === current) return current;\n  const t = typeof value,\n    multi = marker !== undefined;\n  parent = multi && current[0] && current[0].parentNode || parent;\n  if (t === \"string\" || t === \"number\") {\n    if (sharedConfig.context) return current;\n    if (t === \"number\") value = value.toString();\n    if (multi) {\n      let node = current[0];\n      if (node && node.nodeType === 3) {\n        node.data = value;\n      } else node = document.createTextNode(value);\n      current = cleanChildren(parent, current, marker, node);\n    } else {\n      if (current !== \"\" && typeof current === \"string\") {\n        current = parent.firstChild.data = value;\n      } else current = parent.textContent = value;\n    }\n  } else if (value == null || t === \"boolean\") {\n    if (sharedConfig.context) return current;\n    current = cleanChildren(parent, current, marker);\n  } else if (t === \"function\") {\n    createRenderEffect(() => {\n      let v = value();\n      while (typeof v === \"function\") v = v();\n      current = insertExpression(parent, v, current, marker);\n    });\n    return () => current;\n  } else if (Array.isArray(value)) {\n    const array = [];\n    const currentArray = current && Array.isArray(current);\n    if (normalizeIncomingArray(array, value, current, unwrapArray)) {\n      createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));\n      return () => current;\n    }\n    if (sharedConfig.context) {\n      if (!array.length) return current;\n      for (let i = 0; i < array.length; i++) {\n        if (array[i].parentNode) return current = array;\n      }\n    }\n    if (array.length === 0) {\n      current = cleanChildren(parent, current, marker);\n      if (multi) return current;\n    } else if (currentArray) {\n      if (current.length === 0) {\n        appendNodes(parent, array, marker);\n      } else reconcileArrays(parent, current, array);\n    } else {\n      current && cleanChildren(parent);\n      appendNodes(parent, array);\n    }\n    current = array;\n  } else if (value instanceof Node) {\n    if (sharedConfig.context && value.parentNode) return current = multi ? [value] : value;\n    if (Array.isArray(current)) {\n      if (multi) return current = cleanChildren(parent, current, marker, value);\n      cleanChildren(parent, current, null, value);\n    } else if (current == null || current === \"\" || !parent.firstChild) {\n      parent.appendChild(value);\n    } else parent.replaceChild(value, parent.firstChild);\n    current = value;\n  } else console.warn(`Unrecognized value. Skipped inserting`, value);\n  return current;\n}\nfunction normalizeIncomingArray(normalized, array, current, unwrap) {\n  let dynamic = false;\n  for (let i = 0, len = array.length; i < len; i++) {\n    let item = array[i],\n      prev = current && current[i];\n    if (item instanceof Node) {\n      normalized.push(item);\n    } else if (item == null || item === true || item === false) ; else if (Array.isArray(item)) {\n      dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;\n    } else if ((typeof item) === \"function\") {\n      if (unwrap) {\n        while (typeof item === \"function\") item = item();\n        dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;\n      } else {\n        normalized.push(item);\n        dynamic = true;\n      }\n    } else {\n      const value = String(item);\n      if (prev && prev.nodeType === 3) {\n        prev.data = value;\n        normalized.push(prev);\n      } else normalized.push(document.createTextNode(value));\n    }\n  }\n  return dynamic;\n}\nfunction appendNodes(parent, array, marker = null) {\n  for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);\n}\nfunction cleanChildren(parent, current, marker, replacement) {\n  if (marker === undefined) return parent.textContent = \"\";\n  const node = replacement || document.createTextNode(\"\");\n  if (current.length) {\n    let inserted = false;\n    for (let i = current.length - 1; i >= 0; i--) {\n      const el = current[i];\n      if (node !== el) {\n        const isParent = el.parentNode === parent;\n        if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);else isParent && el.remove();\n      } else inserted = true;\n    }\n  } else parent.insertBefore(node, marker);\n  return [node];\n}\nfunction gatherHydratable(element, root) {\n  const templates = element.querySelectorAll(`*[data-hk]`);\n  for (let i = 0; i < templates.length; i++) {\n    const node = templates[i];\n    const key = node.getAttribute(\"data-hk\");\n    if ((!root || key.startsWith(root)) && !sharedConfig.registry.has(key)) sharedConfig.registry.set(key, node);\n  }\n}\nfunction getHydrationKey() {\n  const hydrate = sharedConfig.context;\n  return `${hydrate.id}${hydrate.count++}`;\n}\nfunction NoHydration(props) {\n  return sharedConfig.context ? undefined : props.children;\n}\nfunction Hydration(props) {\n  return props.children;\n}\nfunction voidFn() {}\n\nfunction throwInBrowser(func) {\n  const err = new Error(`${func.name} is not supported in the browser, returning undefined`);\n  console.error(err);\n}\nfunction renderToString(fn, options) {\n  throwInBrowser(renderToString);\n}\nfunction renderToStringAsync(fn, options) {\n  throwInBrowser(renderToStringAsync);\n}\nfunction renderToStream(fn, options) {\n  throwInBrowser(renderToStream);\n}\nfunction ssr(template, ...nodes) {}\nfunction ssrElement(name, props, children, needsId) {}\nfunction ssrClassList(value) {}\nfunction ssrStyle(value) {}\nfunction ssrAttribute(key, value) {}\nfunction ssrHydrationKey() {}\nfunction resolveSSRNode(node) {}\nfunction escape(html) {}\nfunction ssrSpread(props, isSVG, skipChildren) {}\n\nconst isServer = false;\nconst isDev = false;\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nfunction createElement(tagName, isSVG = false) {\n  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);\n}\nconst hydrate = (...args) => {\n  enableHydration();\n  return hydrate$1(...args);\n};\nfunction Portal(props) {\n  const {\n      useShadow\n    } = props,\n    marker = document.createTextNode(\"\"),\n    mount = () => props.mount || document.body,\n    owner = getOwner();\n  let content;\n  let hydrating = !!sharedConfig.context;\n  createEffect(() => {\n    if (hydrating) getOwner().user = hydrating = false;\n    content || (content = runWithOwner(owner, () => props.children));\n    const el = mount();\n    if (el instanceof HTMLHeadElement) {\n      const [clean, setClean] = createSignal(false);\n      const cleanup = () => setClean(true);\n      createRoot(dispose => insert(el, () => !clean() ? content : dispose(), null));\n      onCleanup(cleanup);\n    } else {\n      const container = createElement(props.isSVG ? \"g\" : \"div\", props.isSVG),\n        renderRoot = useShadow && container.attachShadow ? container.attachShadow({\n          mode: \"open\"\n        }) : container;\n      Object.defineProperty(container, \"_$host\", {\n        get() {\n          return marker.parentNode;\n        },\n        configurable: true\n      });\n      insert(renderRoot, content);\n      el.appendChild(container);\n      props.ref && props.ref(container);\n      onCleanup(() => el.removeChild(container));\n    }\n  }, undefined, {\n    render: !hydrating\n  });\n  return marker;\n}\nfunction Dynamic(props) {\n  const [p, others] = splitProps(props, [\"component\"]);\n  const cached = createMemo(() => p.component);\n  return createMemo(() => {\n    const component = cached();\n    switch (typeof component) {\n      case \"function\":\n        Object.assign(component, {\n          [$DEVCOMP]: true\n        });\n        return untrack(() => component(others));\n      case \"string\":\n        const isSvg = SVGElements.has(component);\n        const el = sharedConfig.context ? getNextElement() : createElement(component, isSvg);\n        spread(el, others, isSvg);\n        return el;\n    }\n  });\n}\n\nexport { Aliases, voidFn as Assets, ChildProperties, DOMElements, DelegatedEvents, Dynamic, Hydration, voidFn as HydrationScript, NoHydration, Portal, Properties, SVGElements, SVGNamespace, addEventListener, assign, classList, className, clearDelegatedEvents, delegateEvents, dynamicProperty, escape, voidFn as generateHydrationScript, voidFn as getAssets, getHydrationKey, getNextElement, getNextMarker, getNextMatch, getPropAlias, hydrate, innerHTML, insert, isDev, isServer, render, renderToStream, renderToString, renderToStringAsync, resolveSSRNode, runHydrationEvents, setAttribute, setAttributeNS, spread, ssr, ssrAttribute, ssrClassList, ssrElement, ssrHydrationKey, ssrSpread, ssrStyle, style, template, use, voidFn as useAssets };\n","import { createSignal, onCleanup } from \"solid-js\";\nfunction bindEvent(target, type, handler) {\n    target.addEventListener(type, handler);\n    return () => target.removeEventListener(type, handler);\n}\nfunction intercept([value, setValue], get, set) {\n    return [get ? () => get(value()) : value, set ? (v) => setValue(set(v)) : setValue];\n}\nfunction querySelector(selector) {\n    // Guard against selector being an invalid CSS selector\n    try {\n        return document.querySelector(selector);\n    }\n    catch (e) {\n        return null;\n    }\n}\nfunction scrollToHash(hash, fallbackTop) {\n    const el = querySelector(`#${hash}`);\n    if (el) {\n        el.scrollIntoView();\n    }\n    else if (fallbackTop) {\n        window.scrollTo(0, 0);\n    }\n}\nexport function createMemoryHistory() {\n    const entries = [\"/\"];\n    let index = 0;\n    const listeners = [];\n    const go = (n) => {\n        // https://github.com/remix-run/react-router/blob/682810ca929d0e3c64a76f8d6e465196b7a2ac58/packages/router/history.ts#L245\n        index = Math.max(0, Math.min(index + n, entries.length - 1));\n        const value = entries[index];\n        listeners.forEach(listener => listener(value));\n    };\n    return {\n        get: () => entries[index],\n        set: ({ value, scroll, replace }) => {\n            if (replace) {\n                entries[index] = value;\n            }\n            else {\n                entries.splice(index + 1, entries.length - index, value);\n                index++;\n            }\n            if (scroll) {\n                scrollToHash(value.split(\"#\")[1] || \"\", true);\n            }\n        },\n        back: () => {\n            go(-1);\n        },\n        forward: () => {\n            go(1);\n        },\n        go,\n        listen: (listener) => {\n            listeners.push(listener);\n            return () => {\n                const index = listeners.indexOf(listener);\n                listeners.splice(index, 1);\n            };\n        }\n    };\n}\nexport function createIntegration(get, set, init, utils) {\n    let ignore = false;\n    const wrap = (value) => (typeof value === \"string\" ? { value } : value);\n    const signal = intercept(createSignal(wrap(get()), { equals: (a, b) => a.value === b.value }), undefined, next => {\n        !ignore && set(next);\n        return next;\n    });\n    init &&\n        onCleanup(init((value = get()) => {\n            ignore = true;\n            signal[1](wrap(value));\n            ignore = false;\n        }));\n    return {\n        signal,\n        utils\n    };\n}\nexport function normalizeIntegration(integration) {\n    if (!integration) {\n        return {\n            signal: createSignal({ value: \"\" })\n        };\n    }\n    else if (Array.isArray(integration)) {\n        return {\n            signal: integration\n        };\n    }\n    return integration;\n}\nexport function staticIntegration(obj) {\n    return {\n        signal: [() => obj, next => Object.assign(obj, next)]\n    };\n}\nexport function pathIntegration() {\n    return createIntegration(() => ({\n        value: window.location.pathname + window.location.search + window.location.hash,\n        state: history.state\n    }), ({ value, replace, scroll, state }) => {\n        if (replace) {\n            window.history.replaceState(state, \"\", value);\n        }\n        else {\n            window.history.pushState(state, \"\", value);\n        }\n        scrollToHash(window.location.hash.slice(1), scroll);\n    }, notify => bindEvent(window, \"popstate\", () => notify()), {\n        go: delta => window.history.go(delta)\n    });\n}\nexport function hashIntegration() {\n    return createIntegration(() => window.location.hash.slice(1), ({ value, replace, scroll, state }) => {\n        if (replace) {\n            window.history.replaceState(state, \"\", \"#\" + value);\n        }\n        else {\n            window.location.hash = value;\n        }\n        const hashIndex = value.indexOf(\"#\");\n        const hash = hashIndex >= 0 ? value.slice(hashIndex + 1) : \"\";\n        scrollToHash(hash, scroll);\n    }, notify => bindEvent(window, \"hashchange\", () => notify()), {\n        go: delta => window.history.go(delta),\n        renderPath: path => `#${path}`,\n        parsePath: str => {\n            const to = str.replace(/^.*?#/, \"\");\n            // Hash-only hrefs like `#foo` from plain anchors will come in as `/#foo` whereas a link to\n            // `/foo` will be `/#/foo`. Check if the to starts with a `/` and if not append it as a hash\n            // to the current path so we can handle these in-page anchors correctly.\n            if (!to.startsWith(\"/\")) {\n                const [, path = \"/\"] = window.location.hash.split(\"#\", 2);\n                return `${path}#${to}`;\n            }\n            return to;\n        }\n    });\n}\nexport function memoryIntegration() {\n    const memoryHistory = createMemoryHistory();\n    return createIntegration(memoryHistory.get, memoryHistory.set, memoryHistory.listen, {\n        go: memoryHistory.go\n    });\n}\n","export function createBeforeLeave() {\n    let listeners = new Set();\n    function subscribe(listener) {\n        listeners.add(listener);\n        return () => listeners.delete(listener);\n    }\n    let ignore = false;\n    function confirm(to, options) {\n        if (ignore)\n            return !(ignore = false);\n        const e = {\n            to,\n            options,\n            defaultPrevented: false,\n            preventDefault: () => (e.defaultPrevented = true)\n        };\n        for (const l of listeners)\n            l.listener({\n                ...e,\n                from: l.location,\n                retry: (force) => {\n                    force && (ignore = true);\n                    l.navigate(to, options);\n                }\n            });\n        return !e.defaultPrevented;\n    }\n    return {\n        subscribe,\n        confirm\n    };\n}\n","import { createMemo, getOwner, runWithOwner } from \"solid-js\";\nconst hasSchemeRegex = /^(?:[a-z0-9]+:)?\\/\\//i;\nconst trimPathRegex = /^\\/+|(\\/)\\/+$/g;\nexport function normalizePath(path, omitSlash = false) {\n    const s = path.replace(trimPathRegex, \"$1\");\n    return s ? (omitSlash || /^[?#]/.test(s) ? s : \"/\" + s) : \"\";\n}\nexport function resolvePath(base, path, from) {\n    if (hasSchemeRegex.test(path)) {\n        return undefined;\n    }\n    const basePath = normalizePath(base);\n    const fromPath = from && normalizePath(from);\n    let result = \"\";\n    if (!fromPath || path.startsWith(\"/\")) {\n        result = basePath;\n    }\n    else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {\n        result = basePath + fromPath;\n    }\n    else {\n        result = fromPath;\n    }\n    return (result || \"/\") + normalizePath(path, !result);\n}\nexport function invariant(value, message) {\n    if (value == null) {\n        throw new Error(message);\n    }\n    return value;\n}\nexport function joinPaths(from, to) {\n    return normalizePath(from).replace(/\\/*(\\*.*)?$/g, \"\") + normalizePath(to);\n}\nexport function extractSearchParams(url) {\n    const params = {};\n    url.searchParams.forEach((value, key) => {\n        params[key] = value;\n    });\n    return params;\n}\nexport function createMatcher(path, partial, matchFilters) {\n    const [pattern, splat] = path.split(\"/*\", 2);\n    const segments = pattern.split(\"/\").filter(Boolean);\n    const len = segments.length;\n    return (location) => {\n        const locSegments = location.split(\"/\").filter(Boolean);\n        const lenDiff = locSegments.length - len;\n        if (lenDiff < 0 || (lenDiff > 0 && splat === undefined && !partial)) {\n            return null;\n        }\n        const match = {\n            path: len ? \"\" : \"/\",\n            params: {}\n        };\n        const matchFilter = (s) => matchFilters === undefined ? undefined : matchFilters[s];\n        for (let i = 0; i < len; i++) {\n            const segment = segments[i];\n            const locSegment = locSegments[i];\n            const dynamic = segment[0] === \":\";\n            const key = dynamic ? segment.slice(1) : segment;\n            if (dynamic && matchSegment(locSegment, matchFilter(key))) {\n                match.params[key] = locSegment;\n            }\n            else if (dynamic || !matchSegment(locSegment, segment)) {\n                return null;\n            }\n            match.path += `/${locSegment}`;\n        }\n        if (splat) {\n            const remainder = lenDiff ? locSegments.slice(-lenDiff).join(\"/\") : \"\";\n            if (matchSegment(remainder, matchFilter(splat))) {\n                match.params[splat] = remainder;\n            }\n            else {\n                return null;\n            }\n        }\n        return match;\n    };\n}\nfunction matchSegment(input, filter) {\n    const isEqual = (s) => s.localeCompare(input, undefined, { sensitivity: \"base\" }) === 0;\n    if (filter === undefined) {\n        return true;\n    }\n    else if (typeof filter === \"string\") {\n        return isEqual(filter);\n    }\n    else if (typeof filter === \"function\") {\n        return filter(input);\n    }\n    else if (Array.isArray(filter)) {\n        return filter.some(isEqual);\n    }\n    else if (filter instanceof RegExp) {\n        return filter.test(input);\n    }\n    return false;\n}\nexport function scoreRoute(route) {\n    const [pattern, splat] = route.pattern.split(\"/*\", 2);\n    const segments = pattern.split(\"/\").filter(Boolean);\n    return segments.reduce((score, segment) => score + (segment.startsWith(\":\") ? 2 : 3), segments.length - (splat === undefined ? 0 : 1));\n}\nexport function createMemoObject(fn) {\n    const map = new Map();\n    const owner = getOwner();\n    return new Proxy({}, {\n        get(_, property) {\n            if (!map.has(property)) {\n                runWithOwner(owner, () => map.set(property, createMemo(() => fn()[property])));\n            }\n            return map.get(property)();\n        },\n        getOwnPropertyDescriptor() {\n            return {\n                enumerable: true,\n                configurable: true\n            };\n        },\n        ownKeys() {\n            return Reflect.ownKeys(fn());\n        }\n    });\n}\nexport function mergeSearchString(search, params) {\n    const merged = new URLSearchParams(search);\n    Object.entries(params).forEach(([key, value]) => {\n        if (value == null || value === \"\") {\n            merged.delete(key);\n        }\n        else {\n            merged.set(key, String(value));\n        }\n    });\n    const s = merged.toString();\n    return s ? `?${s}` : \"\";\n}\nexport function expandOptionals(pattern) {\n    let match = /(\\/?\\:[^\\/]+)\\?/.exec(pattern);\n    if (!match)\n        return [pattern];\n    let prefix = pattern.slice(0, match.index);\n    let suffix = pattern.slice(match.index + match[0].length);\n    const prefixes = [prefix, (prefix += match[1])];\n    // This section handles adjacent optional params. We don't actually want all permuations since\n    // that will lead to equivalent routes which have the same number of params. For example\n    // `/:a?/:b?/:c`? only has the unique expansion: `/`, `/:a`, `/:a/:b`, `/:a/:b/:c` and we can\n    // discard `/:b`, `/:c`, `/:b/:c` by building them up in order and not recursing. This also helps\n    // ensure predictability where earlier params have precidence.\n    while ((match = /^(\\/\\:[^\\/]+)\\?/.exec(suffix))) {\n        prefixes.push((prefix += match[1]));\n        suffix = suffix.slice(match[0].length);\n    }\n    return expandOptionals(suffix).reduce((results, expansion) => [...results, ...prefixes.map(p => p + expansion)], []);\n}\n","import { createComponent, createContext, createMemo, createRenderEffect, createSignal, on, onCleanup, untrack, useContext, startTransition, resetErrorBoundaries } from \"solid-js\";\nimport { isServer, delegateEvents } from \"solid-js/web\";\nimport { normalizeIntegration } from \"./integration\";\nimport { createBeforeLeave } from \"./lifecycle\";\nimport { createMemoObject, extractSearchParams, invariant, resolvePath, createMatcher, joinPaths, scoreRoute, mergeSearchString, expandOptionals } from \"./utils\";\nconst MAX_REDIRECTS = 100;\nexport const RouterContextObj = createContext();\nexport const RouteContextObj = createContext();\nexport const useRouter = () => invariant(useContext(RouterContextObj), \"Make sure your app is wrapped in a <Router />\");\nlet TempRoute;\nexport const useRoute = () => TempRoute || useContext(RouteContextObj) || useRouter().base;\nexport const useResolvedPath = (path) => {\n    const route = useRoute();\n    return createMemo(() => route.resolvePath(path()));\n};\nexport const useHref = (to) => {\n    const router = useRouter();\n    return createMemo(() => {\n        const to_ = to();\n        return to_ !== undefined ? router.renderPath(to_) : to_;\n    });\n};\nexport const useNavigate = () => useRouter().navigatorFactory();\nexport const useLocation = () => useRouter().location;\nexport const useIsRouting = () => useRouter().isRouting;\nexport const useMatch = (path, matchFilters) => {\n    const location = useLocation();\n    const matchers = createMemo(() => expandOptionals(path()).map(path => createMatcher(path, undefined, matchFilters)));\n    return createMemo(() => {\n        for (const matcher of matchers()) {\n            const match = matcher(location.pathname);\n            if (match)\n                return match;\n        }\n    });\n};\nexport const useParams = () => useRoute().params;\nexport const useRouteData = () => useRoute().data;\nexport const useSearchParams = () => {\n    const location = useLocation();\n    const navigate = useNavigate();\n    const setSearchParams = (params, options) => {\n        const searchString = untrack(() => mergeSearchString(location.search, params));\n        navigate(location.pathname + searchString + location.hash, {\n            scroll: false,\n            resolve: false,\n            ...options\n        });\n    };\n    return [location.query, setSearchParams];\n};\nexport const useBeforeLeave = (listener) => {\n    const s = useRouter().beforeLeave.subscribe({\n        listener,\n        location: useLocation(),\n        navigate: useNavigate()\n    });\n    onCleanup(s);\n};\nexport function createRoutes(routeDef, base = \"\", fallback) {\n    const { component, data, children } = routeDef;\n    const isLeaf = !children || (Array.isArray(children) && !children.length);\n    const shared = {\n        key: routeDef,\n        element: component\n            ? () => createComponent(component, {})\n            : () => {\n                const { element } = routeDef;\n                return element === undefined && fallback\n                    ? createComponent(fallback, {})\n                    : element;\n            },\n        preload: routeDef.component\n            ? component.preload\n            : routeDef.preload,\n        data\n    };\n    return asArray(routeDef.path).reduce((acc, path) => {\n        for (const originalPath of expandOptionals(path)) {\n            const path = joinPaths(base, originalPath);\n            const pattern = isLeaf ? path : path.split(\"/*\", 1)[0];\n            acc.push({\n                ...shared,\n                originalPath,\n                pattern,\n                matcher: createMatcher(pattern, !isLeaf, routeDef.matchFilters)\n            });\n        }\n        return acc;\n    }, []);\n}\nexport function createBranch(routes, index = 0) {\n    return {\n        routes,\n        score: scoreRoute(routes[routes.length - 1]) * 10000 - index,\n        matcher(location) {\n            const matches = [];\n            for (let i = routes.length - 1; i >= 0; i--) {\n                const route = routes[i];\n                const match = route.matcher(location);\n                if (!match) {\n                    return null;\n                }\n                matches.unshift({\n                    ...match,\n                    route\n                });\n            }\n            return matches;\n        }\n    };\n}\nfunction asArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\nexport function createBranches(routeDef, base = \"\", fallback, stack = [], branches = []) {\n    const routeDefs = asArray(routeDef);\n    for (let i = 0, len = routeDefs.length; i < len; i++) {\n        const def = routeDefs[i];\n        if (def && typeof def === \"object\" && def.hasOwnProperty(\"path\")) {\n            const routes = createRoutes(def, base, fallback);\n            for (const route of routes) {\n                stack.push(route);\n                const isEmptyArray = Array.isArray(def.children) && def.children.length === 0;\n                if (def.children && !isEmptyArray) {\n                    createBranches(def.children, route.pattern, fallback, stack, branches);\n                }\n                else {\n                    const branch = createBranch([...stack], branches.length);\n                    branches.push(branch);\n                }\n                stack.pop();\n            }\n        }\n    }\n    // Stack will be empty on final return\n    return stack.length ? branches : branches.sort((a, b) => b.score - a.score);\n}\nexport function getRouteMatches(branches, location) {\n    for (let i = 0, len = branches.length; i < len; i++) {\n        const match = branches[i].matcher(location);\n        if (match) {\n            return match;\n        }\n    }\n    return [];\n}\nexport function createLocation(path, state) {\n    const origin = new URL(\"http://sar\");\n    const url = createMemo(prev => {\n        const path_ = path();\n        try {\n            return new URL(path_, origin);\n        }\n        catch (err) {\n            console.error(`Invalid path ${path_}`);\n            return prev;\n        }\n    }, origin, {\n        equals: (a, b) => a.href === b.href\n    });\n    const pathname = createMemo(() => url().pathname);\n    const search = createMemo(() => url().search, true);\n    const hash = createMemo(() => url().hash);\n    const key = createMemo(() => \"\");\n    return {\n        get pathname() {\n            return pathname();\n        },\n        get search() {\n            return search();\n        },\n        get hash() {\n            return hash();\n        },\n        get state() {\n            return state();\n        },\n        get key() {\n            return key();\n        },\n        query: createMemoObject(on(search, () => extractSearchParams(url())))\n    };\n}\nexport function createRouterContext(integration, base = \"\", data, out) {\n    const { signal: [source, setSource], utils = {} } = normalizeIntegration(integration);\n    const parsePath = utils.parsePath || (p => p);\n    const renderPath = utils.renderPath || (p => p);\n    const beforeLeave = utils.beforeLeave || createBeforeLeave();\n    const basePath = resolvePath(\"\", base);\n    const output = isServer && out\n        ? Object.assign(out, {\n            matches: [],\n            url: undefined\n        })\n        : undefined;\n    if (basePath === undefined) {\n        throw new Error(`${basePath} is not a valid base path`);\n    }\n    else if (basePath && !source().value) {\n        setSource({ value: basePath, replace: true, scroll: false });\n    }\n    const [isRouting, setIsRouting] = createSignal(false);\n    const start = async (callback) => {\n        setIsRouting(true);\n        try {\n            await startTransition(callback);\n        }\n        finally {\n            setIsRouting(false);\n        }\n    };\n    const [reference, setReference] = createSignal(source().value);\n    const [state, setState] = createSignal(source().state);\n    const location = createLocation(reference, state);\n    const referrers = [];\n    const baseRoute = {\n        pattern: basePath,\n        params: {},\n        path: () => basePath,\n        outlet: () => null,\n        resolvePath(to) {\n            return resolvePath(basePath, to);\n        }\n    };\n    if (data) {\n        try {\n            TempRoute = baseRoute;\n            baseRoute.data = data({\n                data: undefined,\n                params: {},\n                location,\n                navigate: navigatorFactory(baseRoute)\n            });\n        }\n        finally {\n            TempRoute = undefined;\n        }\n    }\n    function navigateFromRoute(route, to, options) {\n        // Untrack in case someone navigates in an effect - don't want to track `reference` or route paths\n        untrack(() => {\n            if (typeof to === \"number\") {\n                if (!to) {\n                    // A delta of 0 means stay at the current location, so it is ignored\n                }\n                else if (utils.go) {\n                    beforeLeave.confirm(to, options) && utils.go(to);\n                }\n                else {\n                    console.warn(\"Router integration does not support relative routing\");\n                }\n                return;\n            }\n            const { replace, resolve, scroll, state: nextState } = {\n                replace: false,\n                resolve: true,\n                scroll: true,\n                ...options\n            };\n            const resolvedTo = resolve ? route.resolvePath(to) : resolvePath(\"\", to);\n            if (resolvedTo === undefined) {\n                throw new Error(`Path '${to}' is not a routable path`);\n            }\n            else if (referrers.length >= MAX_REDIRECTS) {\n                throw new Error(\"Too many redirects\");\n            }\n            const current = reference();\n            if (resolvedTo !== current || nextState !== state()) {\n                if (isServer) {\n                    if (output) {\n                        output.url = resolvedTo;\n                    }\n                    setSource({ value: resolvedTo, replace, scroll, state: nextState });\n                }\n                else if (beforeLeave.confirm(resolvedTo, options)) {\n                    const len = referrers.push({ value: current, replace, scroll, state: state() });\n                    start(() => {\n                        setReference(resolvedTo);\n                        setState(nextState);\n                        resetErrorBoundaries();\n                    }).then(() => {\n                        if (referrers.length === len) {\n                            navigateEnd({\n                                value: resolvedTo,\n                                state: nextState\n                            });\n                        }\n                    });\n                }\n            }\n        });\n    }\n    function navigatorFactory(route) {\n        // Workaround for vite issue (https://github.com/vitejs/vite/issues/3803)\n        route = route || useContext(RouteContextObj) || baseRoute;\n        return (to, options) => navigateFromRoute(route, to, options);\n    }\n    function navigateEnd(next) {\n        const first = referrers[0];\n        if (first) {\n            if (next.value !== first.value || next.state !== first.state) {\n                setSource({\n                    ...next,\n                    replace: first.replace,\n                    scroll: first.scroll\n                });\n            }\n            referrers.length = 0;\n        }\n    }\n    createRenderEffect(() => {\n        const { value, state } = source();\n        // Untrack this whole block so `start` doesn't cause Solid's Listener to be preserved\n        untrack(() => {\n            if (value !== reference()) {\n                start(() => {\n                    setReference(value);\n                    setState(state);\n                });\n            }\n        });\n    });\n    if (!isServer) {\n        function handleAnchorClick(evt) {\n            if (evt.defaultPrevented ||\n                evt.button !== 0 ||\n                evt.metaKey ||\n                evt.altKey ||\n                evt.ctrlKey ||\n                evt.shiftKey)\n                return;\n            const a = evt\n                .composedPath()\n                .find(el => el instanceof Node && el.nodeName.toUpperCase() === \"A\");\n            if (!a || !a.hasAttribute(\"link\"))\n                return;\n            const href = a.href;\n            if (a.target || (!href && !a.hasAttribute(\"state\")))\n                return;\n            const rel = (a.getAttribute(\"rel\") || \"\").split(/\\s+/);\n            if (a.hasAttribute(\"download\") || (rel && rel.includes(\"external\")))\n                return;\n            const url = new URL(href);\n            if (url.origin !== window.location.origin ||\n                (basePath && url.pathname && !url.pathname.toLowerCase().startsWith(basePath.toLowerCase())))\n                return;\n            const to = parsePath(url.pathname + url.search + url.hash);\n            const state = a.getAttribute(\"state\");\n            evt.preventDefault();\n            navigateFromRoute(baseRoute, to, {\n                resolve: false,\n                replace: a.hasAttribute(\"replace\"),\n                scroll: !a.hasAttribute(\"noscroll\"),\n                state: state && JSON.parse(state)\n            });\n        }\n        // ensure delegated events run first\n        delegateEvents([\"click\"]);\n        document.addEventListener(\"click\", handleAnchorClick);\n        onCleanup(() => document.removeEventListener(\"click\", handleAnchorClick));\n    }\n    return {\n        base: baseRoute,\n        out: output,\n        location,\n        isRouting,\n        renderPath,\n        parsePath,\n        navigatorFactory,\n        beforeLeave\n    };\n}\nexport function createRouteContext(router, parent, child, match, params) {\n    const { base, location, navigatorFactory } = router;\n    const { pattern, element: outlet, preload, data } = match().route;\n    const path = createMemo(() => match().path);\n    preload && preload();\n    const route = {\n        parent,\n        pattern,\n        get child() {\n            return child();\n        },\n        path,\n        params,\n        data: parent.data,\n        outlet,\n        resolvePath(to) {\n            return resolvePath(base.path(), to, path());\n        }\n    };\n    if (data) {\n        try {\n            TempRoute = route;\n            route.data = data({ data: parent.data, params, location, navigate: navigatorFactory(route) });\n        }\n        finally {\n            TempRoute = undefined;\n        }\n    }\n    return route;\n}\n","/*@refresh skip*/\nimport { children, createMemo, createRoot, mergeProps, on, Show, splitProps } from \"solid-js\";\nimport { isServer } from \"solid-js/web\";\nimport { pathIntegration, staticIntegration } from \"./integration\";\nimport { createBranches, createRouteContext, createRouterContext, getRouteMatches, RouteContextObj, RouterContextObj, useHref, useLocation, useNavigate, useResolvedPath, useRoute, useRouter } from \"./routing\";\nimport { joinPaths, normalizePath, createMemoObject } from \"./utils\";\nexport const Router = (props) => {\n    const { source, url, base, data, out } = props;\n    const integration = source || (isServer ? staticIntegration({ value: url || \"\" }) : pathIntegration());\n    const routerState = createRouterContext(integration, base, data, out);\n    return (<RouterContextObj.Provider value={routerState}>{props.children}</RouterContextObj.Provider>);\n};\nexport const Routes = (props) => {\n    const router = useRouter();\n    const parentRoute = useRoute();\n    const routeDefs = children(() => props.children);\n    const branches = createMemo(() => createBranches(routeDefs(), joinPaths(parentRoute.pattern, props.base || \"\"), Outlet));\n    const matches = createMemo(() => getRouteMatches(branches(), router.location.pathname));\n    const params = createMemoObject(() => {\n        const m = matches();\n        const params = {};\n        for (let i = 0; i < m.length; i++) {\n            Object.assign(params, m[i].params);\n        }\n        return params;\n    });\n    if (router.out) {\n        router.out.matches.push(matches().map(({ route, path, params }) => ({\n            originalPath: route.originalPath,\n            pattern: route.pattern,\n            path,\n            params\n        })));\n    }\n    const disposers = [];\n    let root;\n    const routeStates = createMemo(on(matches, (nextMatches, prevMatches, prev) => {\n        let equal = prevMatches && nextMatches.length === prevMatches.length;\n        const next = [];\n        for (let i = 0, len = nextMatches.length; i < len; i++) {\n            const prevMatch = prevMatches && prevMatches[i];\n            const nextMatch = nextMatches[i];\n            if (prev && prevMatch && nextMatch.route.key === prevMatch.route.key) {\n                next[i] = prev[i];\n            }\n            else {\n                equal = false;\n                if (disposers[i]) {\n                    disposers[i]();\n                }\n                createRoot(dispose => {\n                    disposers[i] = dispose;\n                    next[i] = createRouteContext(router, next[i - 1] || parentRoute, () => routeStates()[i + 1], () => matches()[i], params);\n                });\n            }\n        }\n        disposers.splice(nextMatches.length).forEach(dispose => dispose());\n        if (prev && equal) {\n            return prev;\n        }\n        root = next[0];\n        return next;\n    }));\n    return (<Show when={routeStates() && root} keyed>\n      {route => <RouteContextObj.Provider value={route}>{route.outlet()}</RouteContextObj.Provider>}\n    </Show>);\n};\nexport const useRoutes = (routes, base) => {\n    return () => <Routes base={base}>{routes}</Routes>;\n};\nexport const Route = (props) => {\n    const childRoutes = children(() => props.children);\n    return mergeProps(props, {\n        get children() {\n            return childRoutes();\n        }\n    });\n};\nexport const Outlet = () => {\n    const route = useRoute();\n    return (<Show when={route.child} keyed>\n      {child => <RouteContextObj.Provider value={child}>{child.outlet()}</RouteContextObj.Provider>}\n    </Show>);\n};\nexport function A(props) {\n    props = mergeProps({ inactiveClass: \"inactive\", activeClass: \"active\" }, props);\n    const [, rest] = splitProps(props, [\n        \"href\",\n        \"state\",\n        \"class\",\n        \"activeClass\",\n        \"inactiveClass\",\n        \"end\"\n    ]);\n    const to = useResolvedPath(() => props.href);\n    const href = useHref(to);\n    const location = useLocation();\n    const isActive = createMemo(() => {\n        const to_ = to();\n        if (to_ === undefined)\n            return false;\n        const path = normalizePath(to_.split(/[?#]/, 1)[0]).toLowerCase();\n        const loc = normalizePath(location.pathname).toLowerCase();\n        return props.end ? path === loc : loc.startsWith(path);\n    });\n    return (<a link {...rest} href={href() || props.href} state={JSON.stringify(props.state)} classList={{\n            ...(props.class && { [props.class]: true }),\n            [props.inactiveClass]: !isActive(),\n            [props.activeClass]: isActive(),\n            ...rest.classList\n        }} aria-current={isActive() ? \"page\" : undefined}/>);\n}\n// deprecated alias exports\nexport { A as Link, A as NavLink };\nexport function Navigate(props) {\n    const navigate = useNavigate();\n    const location = useLocation();\n    const { href, state } = props;\n    const path = typeof href === \"function\" ? href({ navigate, location }) : href;\n    navigate(path, { replace: true, state });\n    return null;\n}\n","class Subscribable {\n  constructor() {\n    this.listeners = [];\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  subscribe(listener) {\n    this.listeners.push(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners = this.listeners.filter(x => x !== listener);\n      this.onUnsubscribe();\n    };\n  }\n\n  hasListeners() {\n    return this.listeners.length > 0;\n  }\n\n  onSubscribe() {// Do nothing\n  }\n\n  onUnsubscribe() {// Do nothing\n  }\n\n}\n\nexport { Subscribable };\n//# sourceMappingURL=subscribable.mjs.map\n","// TYPES\n// UTILS\nconst isServer = typeof window === 'undefined' || 'Deno' in window;\nfunction noop() {\n  return undefined;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nfunction difference(array1, array2) {\n  return array1.filter(x => array2.indexOf(x) === -1);\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n\n  return { ...arg2,\n    queryKey: arg1\n  };\n}\nfunction parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2\n      };\n    }\n\n    return { ...arg2,\n      mutationKey: arg1\n    };\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2,\n      mutationFn: arg1\n    };\n  }\n\n  return { ...arg1\n  };\n}\nfunction parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    queryKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    mutationKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive();\n\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    fetching,\n    predicate,\n    mutationKey\n  } = filters;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\n\nfunction hashQueryKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nfunction partialMatchKey(a, b) {\n  return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  const ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  const prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\nfunction getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n\n  return;\n}\nfunction replaceData(prevData, data, options) {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n    return prevData;\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n\n  return data;\n}\n\nexport { difference, functionalUpdate, getAbortController, hashQueryKey, hashQueryKeyByOptions, isError, isPlainArray, isPlainObject, isQueryKey, isServer, isValidTimeout, matchMutation, matchQuery, noop, parseFilterArgs, parseMutationArgs, parseMutationFilterArgs, parseQueryArgs, partialDeepEqual, partialMatchKey, replaceAt, replaceData, replaceEqualDeep, scheduleMicrotask, shallowEqualObjects, sleep, timeUntilStale };\n//# sourceMappingURL=utils.mjs.map\n","import { Subscribable } from './subscribable.mjs';\nimport { isServer } from './utils.mjs';\n\nclass FocusManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onFocus => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus(); // Listen to visibillitychange and focus\n\n\n        window.addEventListener('visibilitychange', listener, false);\n        window.addEventListener('focus', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener);\n          window.removeEventListener('focus', listener);\n        };\n      }\n\n      return;\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(focused => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n\n  setFocused(focused) {\n    this.focused = focused;\n\n    if (focused) {\n      this.onFocus();\n    }\n  }\n\n  onFocus() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n\n  isFocused() {\n    if (typeof this.focused === 'boolean') {\n      return this.focused;\n    } // document global can be unavailable in react native\n\n\n    if (typeof document === 'undefined') {\n      return true;\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(document.visibilityState);\n  }\n\n}\nconst focusManager = new FocusManager();\n\nexport { FocusManager, focusManager };\n//# sourceMappingURL=focusManager.mjs.map\n","import { Subscribable } from './subscribable.mjs';\nimport { isServer } from './utils.mjs';\n\nclass OnlineManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onOnline => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline(); // Listen to online\n\n\n        window.addEventListener('online', listener, false);\n        window.addEventListener('offline', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', listener);\n          window.removeEventListener('offline', listener);\n        };\n      }\n\n      return;\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(online => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online);\n      } else {\n        this.onOnline();\n      }\n    });\n  }\n\n  setOnline(online) {\n    this.online = online;\n\n    if (online) {\n      this.onOnline();\n    }\n  }\n\n  onOnline() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n\n  isOnline() {\n    if (typeof this.online === 'boolean') {\n      return this.online;\n    }\n\n    if (typeof navigator === 'undefined' || typeof navigator.onLine === 'undefined') {\n      return true;\n    }\n\n    return navigator.onLine;\n  }\n\n}\nconst onlineManager = new OnlineManager();\n\nexport { OnlineManager, onlineManager };\n//# sourceMappingURL=onlineManager.mjs.map\n","import { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { sleep } from './utils.mjs';\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\n\nfunction canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nclass CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n\n}\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        const canContinue = isResolved || !shouldPause();\n\n        if (canContinue) {\n          continueResolve(value);\n        }\n\n        return canContinue;\n      };\n\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n\n        return;\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn == null ? void 0 : continueFn();\n      return didContinue ? promise : Promise.resolve();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}\n\nexport { CancelledError, canFetch, createRetryer, isCancelledError };\n//# sourceMappingURL=retryer.mjs.map\n","const defaultLogger = console;\n\nexport { defaultLogger };\n//# sourceMappingURL=logger.mjs.map\n","import { scheduleMicrotask } from './utils.mjs';\n\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n\n  let notifyFn = callback => {\n    callback();\n  };\n\n  let batchNotifyFn = callback => {\n    callback();\n  };\n\n  const batch = callback => {\n    let result;\n    transactions++;\n\n    try {\n      result = callback();\n    } finally {\n      transactions--;\n\n      if (!transactions) {\n        flush();\n      }\n    }\n\n    return result;\n  };\n\n  const schedule = callback => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n\n\n  const batchCalls = callback => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args);\n      });\n    };\n  };\n\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach(callback => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n\n\n  const setNotifyFunction = fn => {\n    notifyFn = fn;\n  };\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n\n\n  const setBatchNotifyFunction = fn => {\n    batchNotifyFn = fn;\n  };\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction\n  };\n} // SINGLETON\n\nconst notifyManager = createNotifyManager();\n\nexport { createNotifyManager, notifyManager };\n//# sourceMappingURL=notifyManager.mjs.map\n","import { isValidTimeout, isServer } from './utils.mjs';\n\nclass Removable {\n  destroy() {\n    this.clearGcTimeout();\n  }\n\n  scheduleGc() {\n    this.clearGcTimeout();\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.cacheTime);\n    }\n  }\n\n  updateCacheTime(newCacheTime) {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1000);\n  }\n\n  clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout);\n      this.gcTimeout = undefined;\n    }\n  }\n\n}\n\nexport { Removable };\n//# sourceMappingURL=removable.mjs.map\n","import { replaceData, noop, timeUntilStale, getAbortController } from './utils.mjs';\nimport { defaultLogger } from './logger.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { createRetryer, isCancelledError, canFetch } from './retryer.mjs';\nimport { Removable } from './removable.mjs';\n\n// CLASS\nclass Query extends Removable {\n  constructor(config) {\n    super();\n    this.abortSignalConsumed = false;\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.logger = config.logger || defaultLogger;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || getDefaultState(this.options);\n    this.state = this.initialState;\n    this.scheduleGc();\n  }\n\n  get meta() {\n    return this.options.meta;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this);\n    }\n  }\n\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n      manual: options == null ? void 0 : options.manual\n    });\n    return data;\n  }\n\n  setState(state, setStateOptions) {\n    this.dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n\n  cancel(options) {\n    var _this$retryer;\n\n    const promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n\n  reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  }\n\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);\n  }\n\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n\n  onFocus() {\n    var _this$retryer2;\n\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  }\n\n  onOnline() {\n    var _this$retryer3;\n\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter(x => x !== observer);\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n\n        this.scheduleGc();\n      }\n\n      this.cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  getObserversCount() {\n    return this.observers.length;\n  }\n\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.promise) {\n        var _this$retryer4;\n\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n        return this.promise;\n      }\n    } // Update config if passed, otherwise the config from the last execution is used\n\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n\n    const abortController = getAbortController(); // Create query function context\n\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta\n    }; // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true;\n            return abortController.signal;\n          }\n\n          return undefined;\n        }\n      });\n    };\n\n    addSignalProperty(queryFnContext); // Create fetch function\n\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject('Missing queryFn');\n      }\n\n      this.abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    }; // Trigger behavior hook\n\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n    this.revertState = this.state; // Set to fetching state if not already in it\n\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n\n      if (!isCancelledError(error)) {\n        var _this$cache$config$on, _this$cache$config, _this$cache$config$on2, _this$cache$config2;\n\n        // Notify cache callback\n        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, this.state.data, error, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n\n      this.isFetchingOptimistic = false;\n    }; // Try to fetch the data\n\n\n    this.retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _this$cache$config$on3, _this$cache$config3, _this$cache$config$on4, _this$cache$config4;\n\n        if (typeof data === 'undefined') {\n          if (process.env.NODE_ENV !== 'production') {\n            this.logger.error(\"Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: \" + this.queryHash);\n          }\n\n          onError(new Error(this.queryHash + \" data is undefined\"));\n          return;\n        }\n\n        this.setData(data); // Notify cache callback\n\n        (_this$cache$config$on3 = (_this$cache$config3 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on3.call(_this$cache$config3, data, this);\n        (_this$cache$config$on4 = (_this$cache$config4 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on4.call(_this$cache$config4, data, this.state.error, this);\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.dispatch({\n          type: 'failed',\n          failureCount,\n          error\n        });\n      },\n      onPause: () => {\n        this.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.promise = this.retryer.promise;\n    return this.promise;\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      var _action$meta, _action$dataUpdatedAt;\n\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n\n        case 'pause':\n          return { ...state,\n            fetchStatus: 'paused'\n          };\n\n        case 'continue':\n          return { ...state,\n            fetchStatus: 'fetching'\n          };\n\n        case 'fetch':\n          return { ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            })\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            })\n          };\n\n        case 'error':\n          const error = action.error;\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState\n            };\n          }\n\n          return { ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n\n        case 'invalidate':\n          return { ...state,\n            isInvalidated: true\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action);\n      });\n      this.cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\n\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasData = typeof data !== 'undefined';\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}\n\nexport { Query };\n//# sourceMappingURL=query.mjs.map\n","import { hashQueryKeyByOptions, parseFilterArgs, matchQuery } from './utils.mjs';\nimport { Query } from './query.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\n// CLASS\nclass QueryCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.queries = [];\n    this.queriesMap = {};\n  }\n\n  build(client, options, state) {\n    var _options$queryHash;\n\n    const queryKey = options.queryKey;\n    const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey)\n      });\n      this.add(query);\n    }\n\n    return query;\n  }\n\n  add(query) {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query;\n      this.queries.push(query);\n      this.notify({\n        type: 'added',\n        query\n      });\n    }\n  }\n\n  remove(query) {\n    const queryInMap = this.queriesMap[query.queryHash];\n\n    if (queryInMap) {\n      query.destroy();\n      this.queries = this.queries.filter(x => x !== query);\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash];\n      }\n\n      this.notify({\n        type: 'removed',\n        query\n      });\n    }\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        this.remove(query);\n      });\n    });\n  }\n\n  get(queryHash) {\n    return this.queriesMap[queryHash];\n  }\n\n  getAll() {\n    return this.queries;\n  }\n\n  find(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.queries.find(query => matchQuery(filters, query));\n  }\n\n  findAll(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    return Object.keys(filters).length > 0 ? this.queries.filter(query => matchQuery(filters, query)) : this.queries;\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n\n  onFocus() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onFocus();\n      });\n    });\n  }\n\n  onOnline() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onOnline();\n      });\n    });\n  }\n\n}\n\nexport { QueryCache };\n//# sourceMappingURL=queryCache.mjs.map\n","import { defaultLogger } from './logger.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Removable } from './removable.mjs';\nimport { createRetryer, canFetch } from './retryer.mjs';\n\n// CLASS\nclass Mutation extends Removable {\n  constructor(config) {\n    super();\n    this.defaultOptions = config.defaultOptions;\n    this.mutationId = config.mutationId;\n    this.mutationCache = config.mutationCache;\n    this.logger = config.logger || defaultLogger;\n    this.observers = [];\n    this.state = config.state || getDefaultState();\n    this.setOptions(config.options);\n    this.scheduleGc();\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  get meta() {\n    return this.options.meta;\n  }\n\n  setState(state) {\n    this.dispatch({\n      type: 'setState',\n      state\n    });\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the mutation from being garbage collected\n\n      this.clearGcTimeout();\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    this.observers = this.observers.filter(x => x !== observer);\n    this.scheduleGc();\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer\n    });\n  }\n\n  optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc();\n      } else {\n        this.mutationCache.remove(this);\n      }\n    }\n  }\n\n  continue() {\n    var _this$retryer$continu, _this$retryer;\n\n    return (_this$retryer$continu = (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.continue()) != null ? _this$retryer$continu : this.execute();\n  }\n\n  async execute() {\n    const executeMutation = () => {\n      var _this$options$retry;\n\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found');\n          }\n\n          return this.options.mutationFn(this.state.variables);\n        },\n        onFail: (failureCount, error) => {\n          this.dispatch({\n            type: 'failed',\n            failureCount,\n            error\n          });\n        },\n        onPause: () => {\n          this.dispatch({\n            type: 'pause'\n          });\n        },\n        onContinue: () => {\n          this.dispatch({\n            type: 'continue'\n          });\n        },\n        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode\n      });\n      return this.retryer.promise;\n    };\n\n    const restored = this.state.status === 'loading';\n\n    try {\n      var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onSettl, _this$options3;\n\n      if (!restored) {\n        var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;\n\n        this.dispatch({\n          type: 'loading',\n          variables: this.options.variables\n        }); // Notify cache callback\n\n        await ((_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this));\n        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));\n\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables\n          });\n        }\n      }\n\n      const data = await executeMutation(); // Notify cache callback\n\n      await ((_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this));\n      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context)); // Notify cache callback\n\n      await ((_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, data, null, this.state.variables, this.state.context, this));\n      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));\n      this.dispatch({\n        type: 'success',\n        data\n      });\n      return data;\n    } catch (error) {\n      try {\n        var _this$mutationCache$c7, _this$mutationCache$c8, _this$options$onError, _this$options4, _this$mutationCache$c9, _this$mutationCache$c10, _this$options$onSettl2, _this$options5;\n\n        // Notify cache callback\n        await ((_this$mutationCache$c7 = (_this$mutationCache$c8 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c7.call(_this$mutationCache$c8, error, this.state.variables, this.state.context, this));\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n\n        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context)); // Notify cache callback\n\n        await ((_this$mutationCache$c9 = (_this$mutationCache$c10 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c9.call(_this$mutationCache$c10, undefined, error, this.state.variables, this.state.context, this));\n        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, undefined, error, this.state.variables, this.state.context));\n        throw error;\n      } finally {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n    }\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error\n          };\n\n        case 'pause':\n          return { ...state,\n            isPaused: true\n          };\n\n        case 'continue':\n          return { ...state,\n            isPaused: false\n          };\n\n        case 'loading':\n          return { ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false\n          };\n\n        case 'error':\n          return { ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error'\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onMutationUpdate(action);\n      });\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\nfunction getDefaultState() {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined\n  };\n}\n\nexport { Mutation, getDefaultState };\n//# sourceMappingURL=mutation.mjs.map\n","import { notifyManager } from './notifyManager.mjs';\nimport { Mutation } from './mutation.mjs';\nimport { matchMutation, noop } from './utils.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\n// CLASS\nclass MutationCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.mutations = [];\n    this.mutationId = 0;\n  }\n\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : undefined\n    });\n    this.add(mutation);\n    return mutation;\n  }\n\n  add(mutation) {\n    this.mutations.push(mutation);\n    this.notify({\n      type: 'added',\n      mutation\n    });\n  }\n\n  remove(mutation) {\n    this.mutations = this.mutations.filter(x => x !== mutation);\n    this.notify({\n      type: 'removed',\n      mutation\n    });\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.mutations.forEach(mutation => {\n        this.remove(mutation);\n      });\n    });\n  }\n\n  getAll() {\n    return this.mutations;\n  }\n\n  find(filters) {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.mutations.find(mutation => matchMutation(filters, mutation));\n  }\n\n  findAll(filters) {\n    return this.mutations.filter(mutation => matchMutation(filters, mutation));\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n\n  resumePausedMutations() {\n    var _this$resuming;\n\n    this.resuming = ((_this$resuming = this.resuming) != null ? _this$resuming : Promise.resolve()).then(() => {\n      const pausedMutations = this.mutations.filter(x => x.state.isPaused);\n      return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));\n    }).then(() => {\n      this.resuming = undefined;\n    });\n    return this.resuming;\n  }\n\n}\n\nexport { MutationCache };\n//# sourceMappingURL=mutationCache.mjs.map\n","function infiniteQueryBehavior() {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n\n        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        let newPageParams = oldPageParams;\n        let cancelled = false;\n\n        const addSignalProperty = object => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              var _context$signal;\n\n              if ((_context$signal = context.signal) != null && _context$signal.aborted) {\n                cancelled = true;\n              } else {\n                var _context$signal2;\n\n                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener('abort', () => {\n                  cancelled = true;\n                });\n              }\n\n              return context.signal;\n            }\n          });\n        }; // Get query function\n\n\n        const queryFn = context.options.queryFn || (() => Promise.reject('Missing queryFn'));\n\n        const buildNewPages = (pages, param, page, previous) => {\n          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];\n          return previous ? [page, ...pages] : [...pages, page];\n        }; // Create function to fetch a page\n\n\n        const fetchPage = (pages, manual, param, previous) => {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.options.meta\n          };\n          addSignalProperty(queryFnContext);\n          const queryFnResult = queryFn(queryFnContext);\n          const promise = Promise.resolve(queryFnResult).then(page => buildNewPages(pages, param, page, previous));\n          return promise;\n        };\n\n        let promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param);\n        } // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param, true);\n        } // Refetch pages\n        else {\n          newPageParams = [];\n          const manual = typeof context.options.getNextPageParam === 'undefined';\n          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n\n              if (shouldFetchNextPage) {\n                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                return fetchPage(pages, manual, param);\n              }\n\n              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n            });\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams\n        }));\n        return finalPromise;\n      };\n    }\n  };\n}\nfunction getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nfunction getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n\n  return;\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n\n  return;\n}\n\nexport { getNextPageParam, getPreviousPageParam, hasNextPage, hasPreviousPage, infiniteQueryBehavior };\n//# sourceMappingURL=infiniteQueryBehavior.mjs.map\n","import { parseFilterArgs, parseQueryArgs, functionalUpdate, noop, hashQueryKey, partialMatchKey, hashQueryKeyByOptions } from './utils.mjs';\nimport { QueryCache } from './queryCache.mjs';\nimport { MutationCache } from './mutationCache.mjs';\nimport { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior.mjs';\nimport { defaultLogger } from './logger.mjs';\n\n// CLASS\nclass QueryClient {\n  constructor(config = {}) {\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n    this.mountCount = 0;\n\n    if (process.env.NODE_ENV !== 'production' && config.logger) {\n      this.logger.error(\"Passing a custom logger has been deprecated and will be removed in the next major version.\");\n    }\n  }\n\n  mount() {\n    this.mountCount++;\n    if (this.mountCount !== 1) return;\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.queryCache.onFocus();\n      }\n    });\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.queryCache.onOnline();\n      }\n    });\n  }\n\n  unmount() {\n    var _this$unsubscribeFocu, _this$unsubscribeOnli;\n\n    this.mountCount--;\n    if (this.mountCount !== 0) return;\n    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n    this.unsubscribeFocus = undefined;\n    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n    this.unsubscribeOnline = undefined;\n  }\n\n  isFetching(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    filters.fetchStatus = 'fetching';\n    return this.queryCache.findAll(filters).length;\n  }\n\n  isMutating(filters) {\n    return this.mutationCache.findAll({ ...filters,\n      fetching: true\n    }).length;\n  }\n\n  getQueryData(queryKey, filters) {\n    var _this$queryCache$find;\n\n    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n  }\n\n  ensureQueryData(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const cachedData = this.getQueryData(parsedOptions.queryKey);\n    return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(parsedOptions);\n  }\n\n  getQueriesData(queryKeyOrFilters) {\n    return this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey,\n      state\n    }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n\n  setQueryData(queryKey, updater, options) {\n    const query = this.queryCache.find(queryKey);\n    const prevData = query == null ? void 0 : query.state.data;\n    const data = functionalUpdate(updater, prevData);\n\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions);\n    return this.queryCache.build(this, defaultedOptions).setData(data, { ...options,\n      manual: true\n    });\n  }\n\n  setQueriesData(queryKeyOrFilters, updater, options) {\n    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey\n    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));\n  }\n\n  getQueryState(queryKey, filters) {\n    var _this$queryCache$find2;\n\n    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n  }\n\n  removeQueries(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    const queryCache = this.queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n\n  resetQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const queryCache = this.queryCache;\n    const refetchFilters = {\n      type: 'active',\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  cancelQueries(arg1, arg2, arg3) {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true;\n    }\n\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n\n  invalidateQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    return notifyManager.batch(() => {\n      var _ref, _filters$refetchType;\n\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve();\n      }\n\n      const refetchFilters = { ...filters,\n        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  refetchQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      var _options$cancelRefetc;\n\n      return query.fetch(undefined, { ...options,\n        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n        meta: {\n          refetchPage: filters.refetchPage\n        }\n      });\n    }));\n    let promise = Promise.all(promises).then(noop);\n\n    if (!(options != null && options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  fetchQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false;\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n\n  prefetchQuery(arg1, arg2, arg3) {\n    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  fetchInfiniteQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    parsedOptions.behavior = infiniteQueryBehavior();\n    return this.fetchQuery(parsedOptions);\n  }\n\n  prefetchInfiniteQuery(arg1, arg2, arg3) {\n    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  resumePausedMutations() {\n    return this.mutationCache.resumePausedMutations();\n  }\n\n  getQueryCache() {\n    return this.queryCache;\n  }\n\n  getMutationCache() {\n    return this.mutationCache;\n  }\n\n  getLogger() {\n    return this.logger;\n  }\n\n  getDefaultOptions() {\n    return this.defaultOptions;\n  }\n\n  setDefaultOptions(options) {\n    this.defaultOptions = options;\n  }\n\n  setQueryDefaults(queryKey, options) {\n    const result = this.queryDefaults.find(x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.queryDefaults.push({\n        queryKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getQueryDefaults(queryKey) {\n    if (!queryKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter(x => partialMatchKey(queryKey, x.queryKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  setMutationDefaults(mutationKey, options) {\n    const result = this.mutationDefaults.find(x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.mutationDefaults.push({\n        mutationKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getMutationDefaults(mutationKey) {\n    if (!mutationKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.mutationDefaults.find(x => partialMatchKey(mutationKey, x.mutationKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter(x => partialMatchKey(mutationKey, x.mutationKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  defaultQueryOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    const defaultedOptions = { ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    } // dependent default values\n\n\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n    }\n\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n    }\n\n    return defaultedOptions;\n  }\n\n  defaultMutationOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    return { ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n\n  clear() {\n    this.queryCache.clear();\n    this.mutationCache.clear();\n  }\n\n}\n\nexport { QueryClient };\n//# sourceMappingURL=queryClient.mjs.map\n","// TYPES\n// FUNCTIONS\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state\n  };\n} // Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\n\n\nfunction dehydrateQuery(query) {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash\n  };\n}\n\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === 'success';\n}\nfunction dehydrate(client, options = {}) {\n  const mutations = [];\n  const queries = [];\n\n  if (options.dehydrateMutations !== false) {\n    const shouldDehydrateMutation = options.shouldDehydrateMutation || defaultShouldDehydrateMutation;\n    client.getMutationCache().getAll().forEach(mutation => {\n      if (shouldDehydrateMutation(mutation)) {\n        mutations.push(dehydrateMutation(mutation));\n      }\n    });\n  }\n\n  if (options.dehydrateQueries !== false) {\n    const shouldDehydrateQuery = options.shouldDehydrateQuery || defaultShouldDehydrateQuery;\n    client.getQueryCache().getAll().forEach(query => {\n      if (shouldDehydrateQuery(query)) {\n        queries.push(dehydrateQuery(query));\n      }\n    });\n  }\n\n  return {\n    mutations,\n    queries\n  };\n}\nfunction hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return;\n  }\n\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache(); // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const mutations = dehydratedState.mutations || []; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(dehydratedMutation => {\n    var _options$defaultOptio;\n\n    mutationCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio = options.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations),\n      mutationKey: dehydratedMutation.mutationKey\n    }, dehydratedMutation.state);\n  });\n  queries.forEach(dehydratedQuery => {\n    var _options$defaultOptio2;\n\n    const query = queryCache.get(dehydratedQuery.queryHash); // Reset fetch status to idle in the dehydrated state to avoid\n    // query being stuck in fetching state upon hydration\n\n    const dehydratedQueryState = { ...dehydratedQuery.state,\n      fetchStatus: 'idle'\n    }; // Do not hydrate if an existing query exists with newer data\n\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQueryState.dataUpdatedAt) {\n        query.setState(dehydratedQueryState);\n      }\n\n      return;\n    } // Restore query\n\n\n    queryCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio2 = options.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries),\n      queryKey: dehydratedQuery.queryKey,\n      queryHash: dehydratedQuery.queryHash\n    }, dehydratedQueryState);\n  });\n}\n\nexport { defaultShouldDehydrateMutation, defaultShouldDehydrateQuery, dehydrate, hydrate };\n//# sourceMappingURL=hydration.mjs.map\n","import { hydrate, dehydrate } from '@tanstack/query-core';\n\n/**\n * Checks if emitted event is about cache change and not about observers.\n * Useful for persist, where we only want to trigger save when cache is changed.\n */\nconst cacheableEventTypes = ['added', 'removed', 'updated'];\n\nfunction isCacheableEventType(eventType) {\n  return cacheableEventTypes.includes(eventType);\n}\n/**\n * Restores persisted data to the QueryCache\n *  - data obtained from persister.restoreClient\n *  - data is hydrated using hydrateOptions\n * If data is expired, busted, empty, or throws, it runs persister.removeClient\n */\n\n\nasync function persistQueryClientRestore({\n  queryClient,\n  persister,\n  maxAge = 1000 * 60 * 60 * 24,\n  buster = '',\n  hydrateOptions\n}) {\n  try {\n    const persistedClient = await persister.restoreClient();\n\n    if (persistedClient) {\n      if (persistedClient.timestamp) {\n        const expired = Date.now() - persistedClient.timestamp > maxAge;\n        const busted = persistedClient.buster !== buster;\n\n        if (expired || busted) {\n          persister.removeClient();\n        } else {\n          hydrate(queryClient, persistedClient.clientState, hydrateOptions);\n        }\n      } else {\n        persister.removeClient();\n      }\n    }\n  } catch (err) {\n    if (process.env.NODE_ENV !== 'production') {\n      queryClient.getLogger().error(err);\n      queryClient.getLogger().warn('Encountered an error attempting to restore client cache from persisted location. As a precaution, the persisted cache will be discarded.');\n    }\n\n    persister.removeClient();\n  }\n}\n/**\n * Persists data from the QueryCache\n *  - data dehydrated using dehydrateOptions\n *  - data is persisted using persister.persistClient\n */\n\nasync function persistQueryClientSave({\n  queryClient,\n  persister,\n  buster = '',\n  dehydrateOptions\n}) {\n  const persistClient = {\n    buster,\n    timestamp: Date.now(),\n    clientState: dehydrate(queryClient, dehydrateOptions)\n  };\n  await persister.persistClient(persistClient);\n}\n/**\n * Subscribe to QueryCache and MutationCache updates (for persisting)\n * @returns an unsubscribe function (to discontinue monitoring)\n */\n\nfunction persistQueryClientSubscribe(props) {\n  const unsubscribeQueryCache = props.queryClient.getQueryCache().subscribe(event => {\n    if (isCacheableEventType(event.type)) {\n      persistQueryClientSave(props);\n    }\n  });\n  const unusbscribeMutationCache = props.queryClient.getMutationCache().subscribe(event => {\n    if (isCacheableEventType(event.type)) {\n      persistQueryClientSave(props);\n    }\n  });\n  return () => {\n    unsubscribeQueryCache();\n    unusbscribeMutationCache();\n  };\n}\n/**\n * Restores persisted data to QueryCache and persists further changes.\n */\n\nfunction persistQueryClient(props) {\n  let hasUnsubscribed = false;\n  let persistQueryClientUnsubscribe;\n\n  const unsubscribe = () => {\n    hasUnsubscribed = true;\n    persistQueryClientUnsubscribe == null ? void 0 : persistQueryClientUnsubscribe();\n  }; // Attempt restore\n\n\n  const restorePromise = persistQueryClientRestore(props).then(() => {\n    if (!hasUnsubscribed) {\n      // Subscribe to changes in the query cache to trigger the save\n      persistQueryClientUnsubscribe = persistQueryClientSubscribe(props);\n    }\n  });\n  return [unsubscribe, restorePromise];\n}\n\nexport { persistQueryClient, persistQueryClientRestore, persistQueryClientSave, persistQueryClientSubscribe };\n//# sourceMappingURL=persist.mjs.map\n","function createSyncStoragePersister({\n  storage,\n  key = \"REACT_QUERY_OFFLINE_CACHE\",\n  throttleTime = 1000,\n  serialize = JSON.stringify,\n  deserialize = JSON.parse,\n  retry\n}) {\n  if (storage) {\n    const trySave = persistedClient => {\n      try {\n        storage.setItem(key, serialize(persistedClient));\n        return;\n      } catch (error) {\n        return error;\n      }\n    };\n\n    return {\n      persistClient: throttle(persistedClient => {\n        let client = persistedClient;\n        let error = trySave(client);\n        let errorCount = 0;\n\n        while (error && client) {\n          errorCount++;\n          client = retry == null ? void 0 : retry({\n            persistedClient: client,\n            error,\n            errorCount\n          });\n\n          if (client) {\n            error = trySave(client);\n          }\n        }\n      }, throttleTime),\n      restoreClient: () => {\n        const cacheString = storage.getItem(key);\n\n        if (!cacheString) {\n          return;\n        }\n\n        return deserialize(cacheString);\n      },\n      removeClient: () => {\n        storage.removeItem(key);\n      }\n    };\n  }\n\n  return {\n    persistClient: noop,\n    restoreClient: () => undefined,\n    removeClient: noop\n  };\n}\n\nfunction throttle(func, wait = 100) {\n  let timer = null;\n  let params;\n  return function (...args) {\n    params = args;\n\n    if (timer === null) {\n      timer = setTimeout(() => {\n        func(...params);\n        timer = null;\n      }, wait);\n    }\n  };\n} // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\nfunction noop() {}\n\nexport { createSyncStoragePersister };\n//# sourceMappingURL=index.mjs.map\n","import { createContext, useContext, onMount, onCleanup, mergeProps, } from 'solid-js';\nexport const defaultContext = createContext(undefined);\nconst QueryClientSharingContext = createContext(false);\n// If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if Solid Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\nfunction getQueryClientContext(context, contextSharing) {\n    if (context) {\n        return context;\n    }\n    if (contextSharing && typeof window !== 'undefined') {\n        if (!window.SolidQueryClientContext) {\n            window.SolidQueryClientContext = defaultContext;\n        }\n        return window.SolidQueryClientContext;\n    }\n    return defaultContext;\n}\nexport const useQueryClient = ({ context } = {}) => {\n    const queryClient = useContext(getQueryClientContext(context, useContext(QueryClientSharingContext)));\n    if (!queryClient) {\n        throw new Error('No QueryClient set, use QueryClientProvider to set one');\n    }\n    return queryClient;\n};\nexport const QueryClientProvider = (props) => {\n    const mergedProps = mergeProps({\n        contextSharing: false,\n    }, props);\n    onMount(() => {\n        mergedProps.client.mount();\n        if (process.env.NODE_ENV !== 'production' && mergedProps.contextSharing) {\n            mergedProps.client\n                .getLogger()\n                .error(`The contextSharing option has been deprecated and will be removed in the next major version`);\n        }\n    });\n    onCleanup(() => mergedProps.client.unmount());\n    const QueryClientContext = getQueryClientContext(mergedProps.context, mergedProps.contextSharing);\n    return (<QueryClientSharingContext.Provider value={!mergedProps.context && mergedProps.contextSharing}>\n      <QueryClientContext.Provider value={mergedProps.client}>\n        {mergedProps.children}\n      </QueryClientContext.Provider>\n    </QueryClientSharingContext.Provider>);\n};\n","import { createEffect, onCleanup, lazy, type Component } from 'solid-js';\n\nimport { Routes, Route } from '@solidjs/router';\nimport { persistQueryClient } from '@tanstack/query-persist-client-core';\nimport { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister';\nimport { QueryClient, QueryClientProvider } from '@tanstack/solid-query';\n\nconst Home = lazy(() => import('@/pages/Home'));\nconst Hello = lazy(() => import('@/pages/Hello'));\nconst NotFound = lazy(() => import('@/pages/NotFound'));\n\nconst queryClient = new QueryClient({});\n\nconst localStoragePersister = createSyncStoragePersister({\n  storage: window.localStorage,\n});\n\nconst App: Component = () => {\n  createEffect(() => {\n    const [unsubscribe] = persistQueryClient({\n      queryClient,\n      persister: localStoragePersister,\n    });\n    onCleanup(() => unsubscribe());\n  });\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Routes>\n        <Route path=\"/hello\" element={<Hello />} />\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/*\" element={<NotFound />} />\n      </Routes>\n    </QueryClientProvider>\n  );\n};\n\nexport default App;\n","/* @refresh reload */\nimport { Router } from '@solidjs/router';\nimport { render } from 'solid-js/web';\n\nimport '@/index.css';\nimport App from '@/App';\n\nrender(\n  () => (\n    <Router base={import.meta.env.BASE_URL}>\n      <App />\n    </Router>\n  ),\n  document.getElementById('root') as HTMLElement,\n);\n"],"file":"assets/index-44a3fb0d.js"}