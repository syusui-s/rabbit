{"version":3,"file":"resolveAsset-78782a8a.js","sources":["../../node_modules/solid-js/store/dist/store.js","../../src/hooks/createSignalWithStorage.ts","../../src/hooks/usePersistStatus.ts","../../src/utils/resolveAsset.tsx"],"sourcesContent":["import { $PROXY, $TRACK, getListener, batch, createSignal } from 'solid-js';\n\nconst $RAW = Symbol(\"store-raw\"),\n  $NODE = Symbol(\"store-node\"),\n  $HAS = Symbol(\"store-has\"),\n  $SELF = Symbol(\"store-self\");\nfunction wrap$1(value) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps$1)\n    });\n    if (!Array.isArray(value)) {\n      const keys = Object.keys(value),\n        desc = Object.getOwnPropertyDescriptors(value);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const prop = keys[i];\n        if (desc[prop].get) {\n          Object.defineProperty(value, prop, {\n            enumerable: desc[prop].enumerable,\n            get: desc[prop].get.bind(p)\n          });\n        }\n      }\n    }\n  }\n  return p;\n}\nfunction isWrappable(obj) {\n  let proto;\n  return obj != null && typeof obj === \"object\" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));\n}\nfunction unwrap(item, set = new Set()) {\n  let result, unwrapped, v, prop;\n  if (result = item != null && item[$RAW]) return result;\n  if (!isWrappable(item) || set.has(item)) return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item)) item = item.slice(0);else set.add(item);\n    for (let i = 0, l = item.length; i < l; i++) {\n      v = item[i];\n      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item)) item = Object.assign({}, item);else set.add(item);\n    const keys = Object.keys(item),\n      desc = Object.getOwnPropertyDescriptors(item);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      prop = keys[i];\n      if (desc[prop].get) continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getNodes(target, symbol) {\n  let nodes = target[symbol];\n  if (!nodes) Object.defineProperty(target, symbol, {\n    value: nodes = Object.create(null)\n  });\n  return nodes;\n}\nfunction getNode(nodes, property, value) {\n  if (nodes[property]) return nodes[property];\n  const [s, set] = createSignal(value, {\n    equals: false,\n    internal: true\n  });\n  s.$ = set;\n  return nodes[property] = s;\n}\nfunction proxyDescriptor$1(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE) return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  return desc;\n}\nfunction trackSelf(target) {\n  getListener() && getNode(getNodes(target, $NODE), $SELF)();\n}\nfunction ownKeys(target) {\n  trackSelf(target);\n  return Reflect.ownKeys(target);\n}\nconst proxyTraps$1 = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getNodes(target, $NODE);\n    const tracked = nodes[property];\n    let value = tracked ? tracked() : target[property];\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      if (getListener() && (typeof value !== \"function\" || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getNode(nodes, property, value)();\n    }\n    return isWrappable(value) ? wrap$1(value) : value;\n  },\n  has(target, property) {\n    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === $HAS || property === \"__proto__\") return true;\n    getListener() && getNode(getNodes(target, $HAS), property)();\n    return property in target;\n  },\n  set() {\n    return true;\n  },\n  deleteProperty() {\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor$1\n};\nfunction setProperty(state, property, value, deleting = false) {\n  if (!deleting && state[property] === value) return;\n  const prev = state[property],\n    len = state.length;\n  if (value === undefined) {\n    delete state[property];\n    if (state[$HAS] && state[$HAS][property] && prev !== undefined) state[$HAS][property].$();\n  } else {\n    state[property] = value;\n    if (state[$HAS] && state[$HAS][property] && prev === undefined) state[$HAS][property].$();\n  }\n  let nodes = getNodes(state, $NODE),\n    node;\n  if (node = getNode(nodes, property, prev)) node.$(() => value);\n  if (Array.isArray(state) && state.length !== len) {\n    for (let i = state.length; i < len; i++) (node = nodes[i]) && node.$();\n    (node = getNode(nodes, \"length\", len)) && node.$(state.length);\n  }\n  (node = nodes[$SELF]) && node.$();\n}\nfunction mergeStoreNode(state, value) {\n  const keys = Object.keys(value);\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    setProperty(state, key, value[key]);\n  }\n}\nfunction updateArray(current, next) {\n  if (typeof next === \"function\") next = next(current);\n  next = unwrap(next);\n  if (Array.isArray(next)) {\n    if (current === next) return;\n    let i = 0,\n      len = next.length;\n    for (; i < len; i++) {\n      const value = next[i];\n      if (current[i] !== value) setProperty(current, i, value);\n    }\n    setProperty(current, \"length\", len);\n  } else mergeStoreNode(current, next);\n}\nfunction updatePath(current, path, traversed = []) {\n  let part,\n    prev = current;\n  if (path.length > 1) {\n    part = path.shift();\n    const partType = typeof part,\n      isArray = Array.isArray(current);\n    if (Array.isArray(part)) {\n      for (let i = 0; i < part.length; i++) {\n        updatePath(current, [part[i]].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"function\") {\n      for (let i = 0; i < current.length; i++) {\n        if (part(current[i], i)) updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"object\") {\n      const {\n        from = 0,\n        to = current.length - 1,\n        by = 1\n      } = part;\n      for (let i = from; i <= to; i += by) {\n        updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (path.length > 1) {\n      updatePath(current[part], path, [part].concat(traversed));\n      return;\n    }\n    prev = current[part];\n    traversed = [part].concat(traversed);\n  }\n  let value = path[0];\n  if (typeof value === \"function\") {\n    value = value(prev, traversed);\n    if (value === prev) return;\n  }\n  if (part === undefined && value == undefined) return;\n  value = unwrap(value);\n  if (part === undefined || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {\n    mergeStoreNode(prev, value);\n  } else setProperty(current, part, value);\n}\nfunction createStore(...[store, options]) {\n  const unwrappedStore = unwrap(store || {});\n  const isArray = Array.isArray(unwrappedStore);\n  const wrappedStore = wrap$1(unwrappedStore);\n  function setStore(...args) {\n    batch(() => {\n      isArray && args.length === 1 ? updateArray(unwrappedStore, args[0]) : updatePath(unwrappedStore, args);\n    });\n  }\n  return [wrappedStore, setStore];\n}\n\nfunction proxyDescriptor(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || desc.set || !desc.configurable || property === $PROXY || property === $NODE) return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  desc.set = v => target[$PROXY][property] = v;\n  return desc;\n}\nconst proxyTraps = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getNodes(target, $NODE);\n    const tracked = nodes[property];\n    let value = tracked ? tracked() : target[property];\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      const isFunction = typeof value === \"function\";\n      if (getListener() && (!isFunction || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getNode(nodes, property, value)();else if (value != null && isFunction && value === Array.prototype[property]) {\n        return (...args) => batch(() => Array.prototype[property].apply(receiver, args));\n      }\n    }\n    return isWrappable(value) ? wrap(value) : value;\n  },\n  has(target, property) {\n    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === $HAS || property === \"__proto__\") return true;\n    getListener() && getNode(getNodes(target, $HAS), property)();\n    return property in target;\n  },\n  set(target, property, value) {\n    batch(() => setProperty(target, property, unwrap(value)));\n    return true;\n  },\n  deleteProperty(target, property) {\n    batch(() => setProperty(target, property, undefined, true));\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction wrap(value) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps)\n    });\n    const keys = Object.keys(value),\n      desc = Object.getOwnPropertyDescriptors(value);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get\n        });\n      }\n      if (desc[prop].set) {\n        const og = desc[prop].set,\n          set = v => batch(() => og.call(p, v));\n        Object.defineProperty(value, prop, {\n          set\n        });\n      }\n    }\n  }\n  return p;\n}\nfunction createMutable(state, options) {\n  const unwrappedStore = unwrap(state || {});\n  const wrappedStore = wrap(unwrappedStore);\n  return wrappedStore;\n}\nfunction modifyMutable(state, modifier) {\n  batch(() => modifier(unwrap(state)));\n}\n\nconst $ROOT = Symbol(\"store-root\");\nfunction applyState(target, parent, property, merge, key) {\n  const previous = parent[property];\n  if (target === previous) return;\n  if (property !== $ROOT && (!isWrappable(target) || !isWrappable(previous) || key && target[key] !== previous[key])) {\n    setProperty(parent, property, target);\n    return;\n  }\n  if (Array.isArray(target)) {\n    if (target.length && previous.length && (!merge || key && target[0] && target[0][key] != null)) {\n      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;\n      for (start = 0, end = Math.min(previous.length, target.length); start < end && (previous[start] === target[start] || key && previous[start] && target[start] && previous[start][key] === target[start][key]); start++) {\n        applyState(target[start], previous, start, merge, key);\n      }\n      const temp = new Array(target.length),\n        newIndices = new Map();\n      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[start] && target[start] && previous[end][key] === target[newEnd][key]); end--, newEnd--) {\n        temp[newEnd] = previous[end];\n      }\n      if (start > newEnd || start > end) {\n        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);\n        for (; j < target.length; j++) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        }\n        if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n        return;\n      }\n      newIndicesNext = new Array(newEnd + 1);\n      for (j = newEnd; j >= start; j--) {\n        item = target[j];\n        keyVal = key && item ? item[key] : item;\n        i = newIndices.get(keyVal);\n        newIndicesNext[j] = i === undefined ? -1 : i;\n        newIndices.set(keyVal, j);\n      }\n      for (i = start; i <= end; i++) {\n        item = previous[i];\n        keyVal = key && item ? item[key] : item;\n        j = newIndices.get(keyVal);\n        if (j !== undefined && j !== -1) {\n          temp[j] = previous[i];\n          j = newIndicesNext[j];\n          newIndices.set(keyVal, j);\n        }\n      }\n      for (j = start; j < target.length; j++) {\n        if (j in temp) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        } else setProperty(previous, j, target[j]);\n      }\n    } else {\n      for (let i = 0, len = target.length; i < len; i++) {\n        applyState(target[i], previous, i, merge, key);\n      }\n    }\n    if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n    return;\n  }\n  const targetKeys = Object.keys(target);\n  for (let i = 0, len = targetKeys.length; i < len; i++) {\n    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);\n  }\n  const previousKeys = Object.keys(previous);\n  for (let i = 0, len = previousKeys.length; i < len; i++) {\n    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);\n  }\n}\nfunction reconcile(value, options = {}) {\n  const {\n      merge,\n      key = \"id\"\n    } = options,\n    v = unwrap(value);\n  return state => {\n    if (!isWrappable(state) || !isWrappable(v)) return v;\n    const res = applyState(v, {\n      [$ROOT]: state\n    }, $ROOT, merge, key);\n    return res === undefined ? state : res;\n  };\n}\nconst producers = new WeakMap();\nconst setterTraps = {\n  get(target, property) {\n    if (property === $RAW) return target;\n    const value = target[property];\n    let proxy;\n    return isWrappable(value) ? producers.get(value) || (producers.set(value, proxy = new Proxy(value, setterTraps)), proxy) : value;\n  },\n  set(target, property, value) {\n    setProperty(target, property, unwrap(value));\n    return true;\n  },\n  deleteProperty(target, property) {\n    setProperty(target, property, undefined, true);\n    return true;\n  }\n};\nfunction produce(fn) {\n  return state => {\n    if (isWrappable(state)) {\n      let proxy;\n      if (!(proxy = producers.get(state))) {\n        producers.set(state, proxy = new Proxy(state, setterTraps));\n      }\n      fn(proxy);\n    }\n    return state;\n  };\n}\n\nconst DEV = undefined;\n\nexport { $RAW, DEV, createMutable, createStore, modifyMutable, produce, reconcile, unwrap };\n","import { createSignal, createEffect, onMount, type Signal } from 'solid-js';\n\nimport { createStore, SetStoreFunction, type Store, type StoreNode } from 'solid-js/store';\n\ntype GenericStorage<T> = {\n  getItem(key: string): T | null;\n  setItem(key: string, value: T): void;\n};\n\nexport const createStorageWithSerializer = <T>(\n  storageProvider: () => Storage,\n  serializer: (v: T) => string,\n  deserializer: (v: string) => T | null,\n): GenericStorage<T> => {\n  const storage: Storage = storageProvider();\n\n  return {\n    getItem(key: string): T | null {\n      const data = storage.getItem(key);\n      return data != null ? deserializer(data) : null;\n    },\n    setItem(key: string, value: T) {\n      const data = serializer(value);\n      storage.setItem(key, data);\n    },\n  };\n};\n\nexport const createSignalWithStorage = <T>(\n  key: string,\n  initialValue: T,\n  storage: GenericStorage<T>,\n): Signal<T> => {\n  const [loaded, setLoaded] = createSignal<boolean>(false);\n  const [state, setState] = createSignal(initialValue);\n\n  onMount(() => {\n    const data = storage.getItem(key);\n    // If there is no data, default value is used.\n    if (data != null) setState(() => data);\n    setLoaded(true);\n  });\n\n  createEffect(() => {\n    if (loaded()) storage.setItem(key, state());\n  });\n\n  return [state, setState];\n};\n\nexport const createStoreWithStorage = <T extends StoreNode>(\n  key: string,\n  initialValue: T,\n  storage: GenericStorage<T>,\n): [Store<T>, SetStoreFunction<T>] => {\n  const [loaded, setLoaded] = createSignal<boolean>(false);\n  const [state, setState] = createStore<T>(initialValue);\n\n  onMount(() => {\n    const data = storage.getItem(key);\n    // If there is no data, default value is used.\n    if (data != null) setState(data);\n    setLoaded(true);\n  });\n\n  createEffect(() => {\n    if (loaded()) storage.setItem(key, state);\n  });\n\n  return [state, setState];\n};\n","import { Accessor } from 'solid-js';\n\nimport {\n  createStoreWithStorage,\n  createStorageWithSerializer,\n} from '@/hooks/createSignalWithStorage';\nimport { UploaderIds } from '@/utils/imageUpload';\n\ntype PersistStatus = {\n  loggedIn: boolean;\n  agreements: Record<UploaderIds, boolean>;\n};\n\ntype UsePersistStatus = {\n  persistStatus: Accessor<PersistStatus>;\n  loggedIn: () => void;\n  agreeToToS: (uploaderId: UploaderIds) => void;\n  didAgreeToToS: (uploaderId: UploaderIds) => boolean;\n};\n\nconst InitialPersistStatus: PersistStatus = {\n  loggedIn: false,\n  agreements: {\n    nostrBuild: false,\n  },\n};\n\nconst serializer = (persistStatus: PersistStatus): string => JSON.stringify(persistStatus);\n// TODO zod使う\nconst deserializer = (json: string): PersistStatus => JSON.parse(json) as PersistStatus;\n\nconst storage = createStorageWithSerializer(() => window.localStorage, serializer, deserializer);\n\nconst [persistStatus, setPersistStatus] = createStoreWithStorage(\n  'RabbitPersistStatus',\n  InitialPersistStatus,\n  storage,\n);\n\nconst usePersistStatus = (): UsePersistStatus => {\n  const loggedIn = () => {\n    setPersistStatus((current) => ({ ...current, loggedIn: true }));\n  };\n\n  const agreeToToS = (key: UploaderIds) => {\n    setPersistStatus('agreements', (current) => ({ ...current, [key]: true }));\n  };\n\n  const didAgreeToToS = (key: UploaderIds): boolean => persistStatus.agreements[key] ?? false;\n\n  return {\n    persistStatus: () => ({\n      ...InitialPersistStatus,\n      ...persistStatus,\n    }),\n    loggedIn,\n    agreeToToS,\n    didAgreeToToS,\n  };\n};\n\nexport default usePersistStatus;\n","const resolveAsset = (path: string): string => {\n  const baseUrl = new URL(import.meta.env.BASE_URL, window.location.href);\n  return new URL(path, baseUrl).href;\n};\n\nexport default resolveAsset;\n"],"names":["$RAW","$NODE","$HAS","$SELF","wrap$1","value","p","$PROXY","proxyTraps$1","keys","desc","i","l","prop","isWrappable","obj","proto","unwrap","item","set","result","unwrapped","v","getNodes","target","symbol","nodes","getNode","property","createSignal","proxyDescriptor$1","trackSelf","getListener","ownKeys","receiver","$TRACK","tracked","setProperty","state","deleting","prev","len","node","mergeStoreNode","key","updateArray","current","next","updatePath","path","traversed","part","partType","isArray","from","to","by","createStore","store","options","unwrappedStore","wrappedStore","setStore","args","batch","createStorageWithSerializer","storageProvider","serializer","deserializer","storage","data","createStoreWithStorage","initialValue","loaded","setLoaded","setState","onMount","createEffect","InitialPersistStatus","persistStatus","json","setPersistStatus","usePersistStatus","resolveAsset","baseUrl","URL","import","window","location","href"],"mappings":"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","x_google_ignoreList":[0]}